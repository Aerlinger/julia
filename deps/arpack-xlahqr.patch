diff -rupN SRC-old/Makefile SRC/Makefile
--- SRC-old/Makefile	1970-01-01 05:30:00.000000000 +0530
+++ SRC/Makefile	2014-06-01 16:07:38.000000000 +0530
@@ -0,0 +1,582 @@
+# Makefile.in generated by automake 1.14.1 from Makefile.am.
+# SRC/Makefile.  Generated from Makefile.in by configure.
+
+# Copyright (C) 1994-2013 Free Software Foundation, Inc.
+
+# This Makefile.in is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY, to the extent permitted by law; without
+# even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+# PARTICULAR PURPOSE.
+
+
+
+
+am__is_gnu_make = test -n '$(MAKEFILE_LIST)' && test -n '$(MAKELEVEL)'
+am__make_running_with_option = \
+  case $${target_option-} in \
+      ?) ;; \
+      *) echo "am__make_running_with_option: internal error: invalid" \
+              "target option '$${target_option-}' specified" >&2; \
+         exit 1;; \
+  esac; \
+  has_opt=no; \
+  sane_makeflags=$$MAKEFLAGS; \
+  if $(am__is_gnu_make); then \
+    sane_makeflags=$$MFLAGS; \
+  else \
+    case $$MAKEFLAGS in \
+      *\\[\ \	]*) \
+        bs=\\; \
+        sane_makeflags=`printf '%s\n' "$$MAKEFLAGS" \
+          | sed "s/$$bs$$bs[$$bs $$bs	]*//g"`;; \
+    esac; \
+  fi; \
+  skip_next=no; \
+  strip_trailopt () \
+  { \
+    flg=`printf '%s\n' "$$flg" | sed "s/$$1.*$$//"`; \
+  }; \
+  for flg in $$sane_makeflags; do \
+    test $$skip_next = yes && { skip_next=no; continue; }; \
+    case $$flg in \
+      *=*|--*) continue;; \
+        -*I) strip_trailopt 'I'; skip_next=yes;; \
+      -*I?*) strip_trailopt 'I';; \
+        -*O) strip_trailopt 'O'; skip_next=yes;; \
+      -*O?*) strip_trailopt 'O';; \
+        -*l) strip_trailopt 'l'; skip_next=yes;; \
+      -*l?*) strip_trailopt 'l';; \
+      -[dEDm]) skip_next=yes;; \
+      -[JT]) skip_next=yes;; \
+    esac; \
+    case $$flg in \
+      *$$target_option*) has_opt=yes; break;; \
+    esac; \
+  done; \
+  test $$has_opt = yes
+am__make_dryrun = (target_option=n; $(am__make_running_with_option))
+am__make_keepgoing = (target_option=k; $(am__make_running_with_option))
+pkgdatadir = $(datadir)/arpack-ng
+pkgincludedir = $(includedir)/arpack-ng
+pkglibdir = $(libdir)/arpack-ng
+pkglibexecdir = $(libexecdir)/arpack-ng
+am__cd = CDPATH="$${ZSH_VERSION+.}$(PATH_SEPARATOR)" && cd
+install_sh_DATA = $(install_sh) -c -m 644
+install_sh_PROGRAM = $(install_sh) -c
+install_sh_SCRIPT = $(install_sh) -c
+INSTALL_HEADER = $(INSTALL_DATA)
+transform = $(program_transform_name)
+NORMAL_INSTALL = :
+PRE_INSTALL = :
+POST_INSTALL = :
+NORMAL_UNINSTALL = :
+PRE_UNINSTALL = :
+POST_UNINSTALL = :
+build_triplet = x86_64-apple-darwin13.1.0
+host_triplet = x86_64-apple-darwin13.1.0
+subdir = SRC
+DIST_COMMON = $(srcdir)/Makefile.in $(srcdir)/Makefile.am
+ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
+am__aclocal_m4_deps = $(top_srcdir)/m4/ax_blas.m4 \
+	$(top_srcdir)/m4/ax_lapack.m4 $(top_srcdir)/m4/ax_mpi.m4 \
+	$(top_srcdir)/m4/libtool.m4 $(top_srcdir)/m4/ltoptions.m4 \
+	$(top_srcdir)/m4/ltsugar.m4 $(top_srcdir)/m4/ltversion.m4 \
+	$(top_srcdir)/m4/lt~obsolete.m4 $(top_srcdir)/configure.ac
+am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
+	$(ACLOCAL_M4)
+mkinstalldirs = $(install_sh) -d
+CONFIG_CLEAN_FILES =
+CONFIG_CLEAN_VPATH_FILES =
+LTLIBRARIES = $(noinst_LTLIBRARIES)
+libarpacksrc_la_LIBADD =
+am_libarpacksrc_la_OBJECTS = sgetv0.lo slaqrb.lo sstqrb.lo ssortc.lo \
+	ssortr.lo sstatn.lo sstats.lo snaitr.lo snapps.lo snaup2.lo \
+	snaupd.lo snconv.lo sneigh.lo sngets.lo ssaitr.lo ssapps.lo \
+	ssaup2.lo ssaupd.lo ssconv.lo sseigt.lo ssgets.lo sneupd.lo \
+	sseupd.lo ssesrt.lo dgetv0.lo dlaqrb.lo dstqrb.lo dsortc.lo \
+	dsortr.lo dstatn.lo dstats.lo dnaitr.lo dnapps.lo dnaup2.lo \
+	dnaupd.lo dnconv.lo dneigh.lo dngets.lo dsaitr.lo dsapps.lo \
+	dsaup2.lo dsaupd.lo dsconv.lo dseigt.lo dsgets.lo dneupd.lo \
+	dseupd.lo dsesrt.lo cnaitr.lo cnapps.lo cnaup2.lo cnaupd.lo \
+	cneigh.lo cneupd.lo cngets.lo cgetv0.lo csortc.lo cstatn.lo \
+	znaitr.lo znapps.lo znaup2.lo znaupd.lo zneigh.lo zneupd.lo \
+	zngets.lo zgetv0.lo zsortc.lo zstatn.lo
+libarpacksrc_la_OBJECTS = $(am_libarpacksrc_la_OBJECTS)
+AM_V_lt = $(am__v_lt_$(V))
+am__v_lt_ = $(am__v_lt_$(AM_DEFAULT_VERBOSITY))
+am__v_lt_0 = --silent
+am__v_lt_1 = 
+AM_V_P = $(am__v_P_$(V))
+am__v_P_ = $(am__v_P_$(AM_DEFAULT_VERBOSITY))
+am__v_P_0 = false
+am__v_P_1 = :
+AM_V_GEN = $(am__v_GEN_$(V))
+am__v_GEN_ = $(am__v_GEN_$(AM_DEFAULT_VERBOSITY))
+am__v_GEN_0 = @echo "  GEN     " $@;
+am__v_GEN_1 = 
+AM_V_at = $(am__v_at_$(V))
+am__v_at_ = $(am__v_at_$(AM_DEFAULT_VERBOSITY))
+am__v_at_0 = @
+am__v_at_1 = 
+DEFAULT_INCLUDES = -I.
+F77COMPILE = $(F77) $(AM_FFLAGS) $(FFLAGS)
+LTF77COMPILE = $(LIBTOOL) $(AM_V_lt) --tag=F77 $(AM_LIBTOOLFLAGS) \
+	$(LIBTOOLFLAGS) --mode=compile $(F77) $(AM_FFLAGS) $(FFLAGS)
+AM_V_F77 = $(am__v_F77_$(V))
+am__v_F77_ = $(am__v_F77_$(AM_DEFAULT_VERBOSITY))
+am__v_F77_0 = @echo "  F77     " $@;
+am__v_F77_1 = 
+F77LD = $(F77)
+F77LINK = $(LIBTOOL) $(AM_V_lt) --tag=F77 $(AM_LIBTOOLFLAGS) \
+	$(LIBTOOLFLAGS) --mode=link $(F77LD) $(AM_FFLAGS) $(FFLAGS) \
+	$(AM_LDFLAGS) $(LDFLAGS) -o $@
+AM_V_F77LD = $(am__v_F77LD_$(V))
+am__v_F77LD_ = $(am__v_F77LD_$(AM_DEFAULT_VERBOSITY))
+am__v_F77LD_0 = @echo "  F77LD   " $@;
+am__v_F77LD_1 = 
+SOURCES = $(libarpacksrc_la_SOURCES)
+DIST_SOURCES = $(libarpacksrc_la_SOURCES)
+am__can_run_installinfo = \
+  case $$AM_UPDATE_INFO_DIR in \
+    n|no|NO) false;; \
+    *) (install-info --version) >/dev/null 2>&1;; \
+  esac
+am__tagged_files = $(HEADERS) $(SOURCES) $(TAGS_FILES) $(LISP)
+# Read a list of newline-separated strings from the standard input,
+# and print each of them once, without duplicates.  Input order is
+# *not* preserved.
+am__uniquify_input = $(AWK) '\
+  BEGIN { nonempty = 0; } \
+  { items[$$0] = 1; nonempty = 1; } \
+  END { if (nonempty) { for (i in items) print i; }; } \
+'
+# Make sure the list of sources is unique.  This is necessary because,
+# e.g., the same source file might be shared among _SOURCES variables
+# for different programs/libraries.
+am__define_uniq_tagged_files = \
+  list='$(am__tagged_files)'; \
+  unique=`for i in $$list; do \
+    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+  done | $(am__uniquify_input)`
+ETAGS = etags
+CTAGS = ctags
+DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
+ACLOCAL = ${SHELL} /Users/viral/julia/deps/arpack-ng-3.1.5/missing aclocal-1.14
+AMTAR = $${TAR-tar}
+AM_DEFAULT_VERBOSITY = 1
+AR = ar
+AS = as
+AUTOCONF = ${SHELL} /Users/viral/julia/deps/arpack-ng-3.1.5/missing autoconf
+AUTOHEADER = ${SHELL} /Users/viral/julia/deps/arpack-ng-3.1.5/missing autoheader
+AUTOMAKE = ${SHELL} /Users/viral/julia/deps/arpack-ng-3.1.5/missing automake-1.14
+AWK = awk
+BLAS_LIBS = -L/Users/viral/julia/usr/lib -lopenblas
+CC = clang -stdlib=libc++ -mmacosx-version-min=10.7
+CCDEPMODE = depmode=gcc3
+CFLAGS = -g -O2
+CPP = clang -stdlib=libc++ -mmacosx-version-min=10.7 -E
+CPPFLAGS = 
+CYGPATH_W = echo
+DEFS = -DPACKAGE_NAME=\"arpack-ng\" -DPACKAGE_TARNAME=\"arpack-ng\" -DPACKAGE_VERSION=\"3.1.5\" -DPACKAGE_STRING=\"arpack-ng\ 3.1.5\" -DPACKAGE_BUGREPORT=\"http://forge.scilab.org/index.php/p/arpack-ng/issues/\" -DPACKAGE_URL=\"\" -DPACKAGE=\"arpack-ng\" -DVERSION=\"3.1.5\" -DSTDC_HEADERS=1 -DHAVE_SYS_TYPES_H=1 -DHAVE_SYS_STAT_H=1 -DHAVE_STDLIB_H=1 -DHAVE_STRING_H=1 -DHAVE_MEMORY_H=1 -DHAVE_STRINGS_H=1 -DHAVE_INTTYPES_H=1 -DHAVE_STDINT_H=1 -DHAVE_UNISTD_H=1 -DHAVE_DLFCN_H=1 -DLT_OBJDIR=\".libs/\" -DHAVE_BLAS=1 -DHAVE_LAPACK=1
+DEPDIR = .deps
+DLLTOOL = false
+DSYMUTIL = dsymutil
+DUMPBIN = 
+ECHO_C = \c
+ECHO_N = 
+ECHO_T = 
+EGREP = /usr/bin/grep -E
+EXEEXT = 
+F77 = gfortran -mmacosx-version-min=10.7
+FFLAGS =  -fdefault-integer-8  -O2 -fPIC
+FGREP = /usr/bin/grep -F
+FLIBS =  -L/usr/local/Cellar/gfortran/4.8.2/gfortran/lib/gcc/x86_64-apple-darwin13.0.1/4.8.2 -L/usr/local/Cellar/gfortran/4.8.2/gfortran/lib/gcc/x86_64-apple-darwin13.0.1/4.8.2/../../.. -lgfortran -lquadmath -lm
+GREP = /usr/bin/grep
+INSTALL = /usr/bin/install -c
+INSTALL_DATA = ${INSTALL} -m 644
+INSTALL_PROGRAM = ${INSTALL}
+INSTALL_SCRIPT = ${INSTALL}
+INSTALL_STRIP_PROGRAM = $(install_sh) -c -s
+LAPACK_LIBS = -L/Users/viral/julia/usr/lib -lopenblas
+LD = /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/ld
+LDFLAGS = -Wl,-rpath,'/Users/viral/julia/usr/lib'
+LIBOBJS = 
+LIBS = 
+LIBTOOL = $(SHELL) $(top_builddir)/libtool
+LIPO = lipo
+LN_S = ln -s
+LTLIBOBJS = 
+MAINT = #
+MAKEINFO = ${SHELL} /Users/viral/julia/deps/arpack-ng-3.1.5/missing makeinfo
+MANIFEST_TOOL = :
+MKDIR_P = .././install-sh -c -d
+MPIF77 = 
+MPILIBS = 
+NM = /usr/bin/nm
+NMEDIT = nmedit
+OBJDUMP = false
+OBJEXT = o
+OTOOL = otool
+OTOOL64 = :
+PACKAGE = arpack-ng
+PACKAGE_BUGREPORT = http://forge.scilab.org/index.php/p/arpack-ng/issues/
+PACKAGE_NAME = arpack-ng
+PACKAGE_STRING = arpack-ng 3.1.5
+PACKAGE_TARNAME = arpack-ng
+PACKAGE_URL = 
+PACKAGE_VERSION = 3.1.5
+PATH_SEPARATOR = :
+RANLIB = ranlib
+SED = /usr/bin/sed
+SET_MAKE = 
+SHELL = /bin/sh
+STRIP = strip
+VERSION = 3.1.5
+abs_builddir = /Users/viral/julia/deps/arpack-ng-3.1.5/SRC
+abs_srcdir = /Users/viral/julia/deps/arpack-ng-3.1.5/SRC
+abs_top_builddir = /Users/viral/julia/deps/arpack-ng-3.1.5
+abs_top_srcdir = /Users/viral/julia/deps/arpack-ng-3.1.5
+ac_ct_AR = ar
+ac_ct_CC = clang -stdlib=libc++ -mmacosx-version-min=10.7
+ac_ct_DUMPBIN = 
+ac_ct_F77 = 
+am__include = include
+am__leading_dot = .
+am__quote = 
+am__tar = $${TAR-tar} chof - "$$tardir"
+am__untar = $${TAR-tar} xf -
+bindir = ${exec_prefix}/bin
+build = x86_64-apple-darwin13.1.0
+build_alias = x86_64-apple-darwin13.1.0
+build_cpu = x86_64
+build_os = darwin13.1.0
+build_vendor = apple
+builddir = .
+datadir = ${datarootdir}
+datarootdir = ${prefix}/share
+docdir = ${datarootdir}/doc/${PACKAGE_TARNAME}
+dvidir = ${docdir}
+exec_prefix = ${prefix}
+host = x86_64-apple-darwin13.1.0
+host_alias = 
+host_cpu = x86_64
+host_os = darwin13.1.0
+host_vendor = apple
+htmldir = ${docdir}
+includedir = ${prefix}/include
+infodir = ${datarootdir}/info
+install_sh = ${SHELL} /Users/viral/julia/deps/arpack-ng-3.1.5/install-sh
+libdir = /Users/viral/julia/usr/lib
+libexecdir = ${exec_prefix}/libexec
+localedir = ${datarootdir}/locale
+localstatedir = ${prefix}/var
+mandir = ${datarootdir}/man
+mkdir_p = $(MKDIR_P)
+oldincludedir = /usr/include
+pdfdir = ${docdir}
+prefix = /Users/viral/julia/usr
+program_transform_name = s,x,x,
+psdir = ${docdir}
+sbindir = ${exec_prefix}/sbin
+sharedstatedir = ${prefix}/com
+srcdir = .
+sysconfdir = ${prefix}/etc
+target_alias = 
+top_build_prefix = ../
+top_builddir = ..
+top_srcdir = ..
+noinst_LTLIBRARIES = libarpacksrc.la
+libarpacksrc_la_SOURCES = \
+	sgetv0.f slaqrb.f sstqrb.f ssortc.f ssortr.f sstatn.f sstats.f \
+	snaitr.f snapps.f snaup2.f snaupd.f snconv.f sneigh.f sngets.f \
+	ssaitr.f ssapps.f ssaup2.f ssaupd.f ssconv.f sseigt.f ssgets.f \
+	sneupd.f sseupd.f ssesrt.f \
+	dgetv0.f dlaqrb.f dstqrb.f dsortc.f dsortr.f dstatn.f dstats.f \
+	dnaitr.f dnapps.f dnaup2.f dnaupd.f dnconv.f dneigh.f dngets.f \
+	dsaitr.f dsapps.f dsaup2.f dsaupd.f dsconv.f dseigt.f dsgets.f \
+	dneupd.f dseupd.f dsesrt.f \
+	cnaitr.f cnapps.f cnaup2.f cnaupd.f cneigh.f cneupd.f cngets.f \
+        cgetv0.f csortc.f cstatn.f \
+	znaitr.f znapps.f znaup2.f znaupd.f zneigh.f zneupd.f zngets.f \
+        zgetv0.f zsortc.f zstatn.f
+
+EXTRA_DIST = debug.h stat.h version.h
+all: all-am
+
+.SUFFIXES:
+.SUFFIXES: .f .lo .o .obj
+$(srcdir)/Makefile.in: # $(srcdir)/Makefile.am  $(am__configure_deps)
+	@for dep in $?; do \
+	  case '$(am__configure_deps)' in \
+	    *$$dep*) \
+	      ( cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh ) \
+	        && { if test -f $@; then exit 0; else break; fi; }; \
+	      exit 1;; \
+	  esac; \
+	done; \
+	echo ' cd $(top_srcdir) && $(AUTOMAKE) --foreign SRC/Makefile'; \
+	$(am__cd) $(top_srcdir) && \
+	  $(AUTOMAKE) --foreign SRC/Makefile
+.PRECIOUS: Makefile
+Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status
+	@case '$?' in \
+	  *config.status*) \
+	    cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh;; \
+	  *) \
+	    echo ' cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)'; \
+	    cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe);; \
+	esac;
+
+$(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+
+$(top_srcdir)/configure: # $(am__configure_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+$(ACLOCAL_M4): # $(am__aclocal_m4_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+$(am__aclocal_m4_deps):
+
+clean-noinstLTLIBRARIES:
+	-test -z "$(noinst_LTLIBRARIES)" || rm -f $(noinst_LTLIBRARIES)
+	@list='$(noinst_LTLIBRARIES)'; \
+	locs=`for p in $$list; do echo $$p; done | \
+	      sed 's|^[^/]*$$|.|; s|/[^/]*$$||; s|$$|/so_locations|' | \
+	      sort -u`; \
+	test -z "$$locs" || { \
+	  echo rm -f $${locs}; \
+	  rm -f $${locs}; \
+	}
+
+libarpacksrc.la: $(libarpacksrc_la_OBJECTS) $(libarpacksrc_la_DEPENDENCIES) $(EXTRA_libarpacksrc_la_DEPENDENCIES) 
+	$(AM_V_F77LD)$(F77LINK)  $(libarpacksrc_la_OBJECTS) $(libarpacksrc_la_LIBADD) $(LIBS)
+
+mostlyclean-compile:
+	-rm -f *.$(OBJEXT)
+
+distclean-compile:
+	-rm -f *.tab.c
+
+.f.o:
+	$(AM_V_F77)$(F77COMPILE) -c -o $@ $<
+
+.f.obj:
+	$(AM_V_F77)$(F77COMPILE) -c -o $@ `$(CYGPATH_W) '$<'`
+
+.f.lo:
+	$(AM_V_F77)$(LTF77COMPILE) -c -o $@ $<
+
+mostlyclean-libtool:
+	-rm -f *.lo
+
+clean-libtool:
+	-rm -rf .libs _libs
+
+ID: $(am__tagged_files)
+	$(am__define_uniq_tagged_files); mkid -fID $$unique
+tags: tags-am
+TAGS: tags
+
+tags-am: $(TAGS_DEPENDENCIES) $(am__tagged_files)
+	set x; \
+	here=`pwd`; \
+	$(am__define_uniq_tagged_files); \
+	shift; \
+	if test -z "$(ETAGS_ARGS)$$*$$unique"; then :; else \
+	  test -n "$$unique" || unique=$$empty_fix; \
+	  if test $$# -gt 0; then \
+	    $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
+	      "$$@" $$unique; \
+	  else \
+	    $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
+	      $$unique; \
+	  fi; \
+	fi
+ctags: ctags-am
+
+CTAGS: ctags
+ctags-am: $(TAGS_DEPENDENCIES) $(am__tagged_files)
+	$(am__define_uniq_tagged_files); \
+	test -z "$(CTAGS_ARGS)$$unique" \
+	  || $(CTAGS) $(CTAGSFLAGS) $(AM_CTAGSFLAGS) $(CTAGS_ARGS) \
+	     $$unique
+
+GTAGS:
+	here=`$(am__cd) $(top_builddir) && pwd` \
+	  && $(am__cd) $(top_srcdir) \
+	  && gtags -i $(GTAGS_ARGS) "$$here"
+cscopelist: cscopelist-am
+
+cscopelist-am: $(am__tagged_files)
+	list='$(am__tagged_files)'; \
+	case "$(srcdir)" in \
+	  [\\/]* | ?:[\\/]*) sdir="$(srcdir)" ;; \
+	  *) sdir=$(subdir)/$(srcdir) ;; \
+	esac; \
+	for i in $$list; do \
+	  if test -f "$$i"; then \
+	    echo "$(subdir)/$$i"; \
+	  else \
+	    echo "$$sdir/$$i"; \
+	  fi; \
+	done >> $(top_builddir)/cscope.files
+
+distclean-tags:
+	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags
+
+distdir: $(DISTFILES)
+	@srcdirstrip=`echo "$(srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
+	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
+	list='$(DISTFILES)'; \
+	  dist_files=`for file in $$list; do echo $$file; done | \
+	  sed -e "s|^$$srcdirstrip/||;t" \
+	      -e "s|^$$topsrcdirstrip/|$(top_builddir)/|;t"`; \
+	case $$dist_files in \
+	  */*) $(MKDIR_P) `echo "$$dist_files" | \
+			   sed '/\//!d;s|^|$(distdir)/|;s,/[^/]*$$,,' | \
+			   sort -u` ;; \
+	esac; \
+	for file in $$dist_files; do \
+	  if test -f $$file || test -d $$file; then d=.; else d=$(srcdir); fi; \
+	  if test -d $$d/$$file; then \
+	    dir=`echo "/$$file" | sed -e 's,/[^/]*$$,,'`; \
+	    if test -d "$(distdir)/$$file"; then \
+	      find "$(distdir)/$$file" -type d ! -perm -700 -exec chmod u+rwx {} \;; \
+	    fi; \
+	    if test -d $(srcdir)/$$file && test $$d != $(srcdir); then \
+	      cp -fpR $(srcdir)/$$file "$(distdir)$$dir" || exit 1; \
+	      find "$(distdir)/$$file" -type d ! -perm -700 -exec chmod u+rwx {} \;; \
+	    fi; \
+	    cp -fpR $$d/$$file "$(distdir)$$dir" || exit 1; \
+	  else \
+	    test -f "$(distdir)/$$file" \
+	    || cp -p $$d/$$file "$(distdir)/$$file" \
+	    || exit 1; \
+	  fi; \
+	done
+check-am: all-am
+check: check-am
+all-am: Makefile $(LTLIBRARIES)
+installdirs:
+install: install-am
+install-exec: install-exec-am
+install-data: install-data-am
+uninstall: uninstall-am
+
+install-am: all-am
+	@$(MAKE) $(AM_MAKEFLAGS) install-exec-am install-data-am
+
+installcheck: installcheck-am
+install-strip:
+	if test -z '$(STRIP)'; then \
+	  $(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
+	    install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
+	      install; \
+	else \
+	  $(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
+	    install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
+	    "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'" install; \
+	fi
+mostlyclean-generic:
+
+clean-generic:
+
+distclean-generic:
+	-test -z "$(CONFIG_CLEAN_FILES)" || rm -f $(CONFIG_CLEAN_FILES)
+	-test . = "$(srcdir)" || test -z "$(CONFIG_CLEAN_VPATH_FILES)" || rm -f $(CONFIG_CLEAN_VPATH_FILES)
+
+maintainer-clean-generic:
+	@echo "This command is intended for maintainers to use"
+	@echo "it deletes files that may require special tools to rebuild."
+clean: clean-am
+
+clean-am: clean-generic clean-libtool clean-noinstLTLIBRARIES \
+	mostlyclean-am
+
+distclean: distclean-am
+	-rm -f Makefile
+distclean-am: clean-am distclean-compile distclean-generic \
+	distclean-tags
+
+dvi: dvi-am
+
+dvi-am:
+
+html: html-am
+
+html-am:
+
+info: info-am
+
+info-am:
+
+install-data-am:
+
+install-dvi: install-dvi-am
+
+install-dvi-am:
+
+install-exec-am:
+
+install-html: install-html-am
+
+install-html-am:
+
+install-info: install-info-am
+
+install-info-am:
+
+install-man:
+
+install-pdf: install-pdf-am
+
+install-pdf-am:
+
+install-ps: install-ps-am
+
+install-ps-am:
+
+installcheck-am:
+
+maintainer-clean: maintainer-clean-am
+	-rm -f Makefile
+maintainer-clean-am: distclean-am maintainer-clean-generic
+
+mostlyclean: mostlyclean-am
+
+mostlyclean-am: mostlyclean-compile mostlyclean-generic \
+	mostlyclean-libtool
+
+pdf: pdf-am
+
+pdf-am:
+
+ps: ps-am
+
+ps-am:
+
+uninstall-am:
+
+.MAKE: install-am install-strip
+
+.PHONY: CTAGS GTAGS TAGS all all-am check check-am clean clean-generic \
+	clean-libtool clean-noinstLTLIBRARIES cscopelist-am ctags \
+	ctags-am distclean distclean-compile distclean-generic \
+	distclean-libtool distclean-tags distdir dvi dvi-am html \
+	html-am info info-am install install-am install-data \
+	install-data-am install-dvi install-dvi-am install-exec \
+	install-exec-am install-html install-html-am install-info \
+	install-info-am install-man install-pdf install-pdf-am \
+	install-ps install-ps-am install-strip installcheck \
+	installcheck-am installdirs maintainer-clean \
+	maintainer-clean-generic mostlyclean mostlyclean-compile \
+	mostlyclean-generic mostlyclean-libtool pdf pdf-am ps ps-am \
+	tags tags-am uninstall uninstall-am
+
+
+# Tell versions [3.59,3.63) of GNU make to not export all variables.
+# Otherwise a system limit (for SysV at least) may be exceeded.
+.NOEXPORT:
diff -rupN SRC-old/Makefile.am SRC/Makefile.am
--- SRC-old/Makefile.am	2014-06-01 16:07:19.000000000 +0530
+++ SRC/Makefile.am	2014-06-01 16:07:38.000000000 +0530
@@ -11,6 +11,7 @@ libarpacksrc_la_SOURCES = \
 	cnaitr.f cnapps.f cnaup2.f cnaupd.f cneigh.f cneupd.f cngets.f \
         cgetv0.f csortc.f cstatn.f \
 	znaitr.f znapps.f znaup2.f znaupd.f zneigh.f zneupd.f zngets.f \
-        zgetv0.f zsortc.f zstatn.f
+        zgetv0.f zsortc.f zstatn.f \
+	clahqr2.f dlahqr2.f slahqr2.f zlahqr2.f
 
 EXTRA_DIST = debug.h stat.h version.h
\ No newline at end of file
diff -rupN SRC-old/Makefile.in SRC/Makefile.in
--- SRC-old/Makefile.in	2014-06-01 16:07:19.000000000 +0530
+++ SRC/Makefile.in	2014-06-01 16:07:44.000000000 +0530
@@ -104,7 +104,8 @@ am_libarpacksrc_la_OBJECTS = sgetv0.lo s
 	dseupd.lo dsesrt.lo cnaitr.lo cnapps.lo cnaup2.lo cnaupd.lo \
 	cneigh.lo cneupd.lo cngets.lo cgetv0.lo csortc.lo cstatn.lo \
 	znaitr.lo znapps.lo znaup2.lo znaupd.lo zneigh.lo zneupd.lo \
-	zngets.lo zgetv0.lo zsortc.lo zstatn.lo
+	zngets.lo zgetv0.lo zsortc.lo zstatn.lo clahqr2.lo dlahqr2.lo \
+	slahqr2.lo zlahqr2.lo
 libarpacksrc_la_OBJECTS = $(am_libarpacksrc_la_OBJECTS)
 AM_V_lt = $(am__v_lt_@AM_V@)
 am__v_lt_ = $(am__v_lt_@AM_DEFAULT_V@)
@@ -302,7 +303,8 @@ libarpacksrc_la_SOURCES = \
 	cnaitr.f cnapps.f cnaup2.f cnaupd.f cneigh.f cneupd.f cngets.f \
         cgetv0.f csortc.f cstatn.f \
 	znaitr.f znapps.f znaup2.f znaupd.f zneigh.f zneupd.f zngets.f \
-        zgetv0.f zsortc.f zstatn.f
+        zgetv0.f zsortc.f zstatn.f \
+	clahqr2.f dlahqr2.f slahqr2.f zlahqr2.f
 
 EXTRA_DIST = debug.h stat.h version.h
 all: all-am
diff -rupN SRC-old/clahqr2.f SRC/clahqr2.f
--- SRC-old/clahqr2.f	1970-01-01 05:30:00.000000000 +0530
+++ SRC/clahqr2.f	2014-06-01 16:07:38.000000000 +0530
@@ -0,0 +1,384 @@
+      SUBROUTINE CLAHQR2( WANTT, WANTZ, N, ILO, IHI, H, LDH, W, ILOZ,
+     $                   IHIZ, Z, LDZ, INFO )
+*
+*  -- LAPACK auxiliary routine (version 2.0) --
+*     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
+*     Courant Institute, Argonne National Lab, and Rice University
+*     September 30, 1994
+*
+*     .. Scalar Arguments ..
+      LOGICAL            WANTT, WANTZ
+      INTEGER            IHI, IHIZ, ILO, ILOZ, INFO, LDH, LDZ, N
+*     ..
+*     .. Array Arguments ..
+      COMPLEX            H( LDH, * ), W( * ), Z( LDZ, * )
+*     ..
+*
+*  Purpose
+*  =======
+*
+*  CLAHQR is an auxiliary routine called by CHSEQR to update the
+*  eigenvalues and Schur decomposition already computed by CHSEQR, by
+*  dealing with the Hessenberg submatrix in rows and columns ILO to IHI.
+*
+*  Arguments
+*  =========
+*
+*  WANTT   (input) LOGICAL
+*          = .TRUE. : the full Schur form T is required;
+*          = .FALSE.: only eigenvalues are required.
+*
+*  WANTZ   (input) LOGICAL
+*          = .TRUE. : the matrix of Schur vectors Z is required;
+*          = .FALSE.: Schur vectors are not required.
+*
+*  N       (input) INTEGER
+*          The order of the matrix H.  N >= 0.
+*
+*  ILO     (input) INTEGER
+*  IHI     (input) INTEGER
+*          It is assumed that H is already upper triangular in rows and
+*          columns IHI+1:N, and that H(ILO,ILO-1) = 0 (unless ILO = 1).
+*          CLAHQR works primarily with the Hessenberg submatrix in rows
+*          and columns ILO to IHI, but applies transformations to all of
+*          H if WANTT is .TRUE..
+*          1 <= ILO <= max(1,IHI); IHI <= N.
+*
+*  H       (input/output) COMPLEX array, dimension (LDH,N)
+*          On entry, the upper Hessenberg matrix H.
+*          On exit, if WANTT is .TRUE., H is upper triangular in rows
+*          and columns ILO:IHI, with any 2-by-2 diagonal blocks in
+*          standard form. If WANTT is .FALSE., the contents of H are
+*          unspecified on exit.
+*
+*  LDH     (input) INTEGER
+*          The leading dimension of the array H. LDH >= max(1,N).
+*
+*  W       (output) COMPLEX array, dimension (N)
+*          The computed eigenvalues ILO to IHI are stored in the
+*          corresponding elements of W. If WANTT is .TRUE., the
+*          eigenvalues are stored in the same order as on the diagonal
+*          of the Schur form returned in H, with W(i) = H(i,i).
+*
+*  ILOZ    (input) INTEGER
+*  IHIZ    (input) INTEGER
+*          Specify the rows of Z to which transformations must be
+*          applied if WANTZ is .TRUE..
+*          1 <= ILOZ <= ILO; IHI <= IHIZ <= N.
+*
+*  Z       (input/output) COMPLEX array, dimension (LDZ,N)
+*          If WANTZ is .TRUE., on entry Z must contain the current
+*          matrix Z of transformations accumulated by CHSEQR, and on
+*          exit Z has been updated; transformations are applied only to
+*          the submatrix Z(ILOZ:IHIZ,ILO:IHI).
+*          If WANTZ is .FALSE., Z is not referenced.
+*
+*  LDZ     (input) INTEGER
+*          The leading dimension of the array Z. LDZ >= max(1,N).
+*
+*  INFO    (output) INTEGER
+*          = 0: successful exit
+*          > 0: if INFO = i, CLAHQR failed to compute all the
+*               eigenvalues ILO to IHI in a total of 30*(IHI-ILO+1)
+*               iterations; elements i+1:ihi of W contain those
+*               eigenvalues which have been successfully computed.
+*
+*  =====================================================================
+*
+*     .. Parameters ..
+      COMPLEX            ZERO, ONE
+      PARAMETER          ( ZERO = ( 0.0E+0, 0.0E+0 ),
+     $                   ONE = ( 1.0E+0, 0.0E+0 ) )
+      REAL               RZERO, HALF
+      PARAMETER          ( RZERO = 0.0E+0, HALF = 0.5E+0 )
+*     ..
+*     .. Local Scalars ..
+      INTEGER            I, I1, I2, ITN, ITS, J, K, L, M, NH, NZ
+      REAL               H10, H21, RTEMP, S, SMLNUM, T2, TST1, ULP
+      COMPLEX            CDUM, H11, H11S, H22, SUM, T, T1, TEMP, U, V2,
+     $                   X, Y
+*     ..
+*     .. Local Arrays ..
+      REAL               RWORK( 1 )
+      COMPLEX            V( 2 )
+*     ..
+*     .. External Functions ..
+      REAL               CLANHS, SLAMCH
+      COMPLEX            CLADIV
+      EXTERNAL           CLANHS, SLAMCH, CLADIV
+*     ..
+*     .. External Subroutines ..
+      EXTERNAL           CCOPY, CLARFG, CSCAL
+*     ..
+*     .. Intrinsic Functions ..
+      INTRINSIC          ABS, AIMAG, CONJG, MAX, MIN, REAL, SQRT
+*     ..
+*     .. Statement Functions ..
+      REAL               CABS1
+*     ..
+*     .. Statement Function definitions ..
+      CABS1( CDUM ) = ABS( REAL( CDUM ) ) + ABS( AIMAG( CDUM ) )
+*     ..
+*     .. Executable Statements ..
+*
+      INFO = 0
+*
+*     Quick return if possible
+*
+      IF( N.EQ.0 )
+     $   RETURN
+      IF( ILO.EQ.IHI ) THEN
+         W( ILO ) = H( ILO, ILO )
+         RETURN
+      END IF
+*
+      NH = IHI - ILO + 1
+      NZ = IHIZ - ILOZ + 1
+*
+*     Set machine-dependent constants for the stopping criterion.
+*     If norm(H) <= sqrt(OVFL), overflow should not occur.
+*
+      ULP = SLAMCH( 'Precision' )
+      SMLNUM = SLAMCH( 'Safe minimum' ) / ULP
+*
+*     I1 and I2 are the indices of the first row and last column of H
+*     to which transformations must be applied. If eigenvalues only are
+*     being computed, I1 and I2 are set inside the main loop.
+*
+      IF( WANTT ) THEN
+         I1 = 1
+         I2 = N
+      END IF
+*
+*     ITN is the total number of QR iterations allowed.
+*
+      ITN = 30*NH
+*
+*     The main loop begins here. I is the loop index and decreases from
+*     IHI to ILO in steps of 1. Each iteration of the loop works
+*     with the active submatrix in rows and columns L to I.
+*     Eigenvalues I+1 to IHI have already converged. Either L = ILO, or
+*     H(L,L-1) is negligible so that the matrix splits.
+*
+      I = IHI
+   10 CONTINUE
+      IF( I.LT.ILO )
+     $   GO TO 130
+*
+*     Perform QR iterations on rows and columns ILO to I until a
+*     submatrix of order 1 splits off at the bottom because a
+*     subdiagonal element has become negligible.
+*
+      L = ILO
+      DO 110 ITS = 0, ITN
+*
+*        Look for a single small subdiagonal element.
+*
+         DO 20 K = I, L + 1, -1
+            TST1 = CABS1( H( K-1, K-1 ) ) + CABS1( H( K, K ) )
+            IF( TST1.EQ.RZERO )
+     $         TST1 = CLANHS( '1', I-L+1, H( L, L ), LDH, RWORK )
+            IF( ABS( REAL( H( K, K-1 ) ) ).LE.MAX( ULP*TST1, SMLNUM ) )
+     $         GO TO 30
+   20    CONTINUE
+   30    CONTINUE
+         L = K
+         IF( L.GT.ILO ) THEN
+*
+*           H(L,L-1) is negligible
+*
+            H( L, L-1 ) = ZERO
+         END IF
+*
+*        Exit from loop if a submatrix of order 1 has split off.
+*
+         IF( L.GE.I )
+     $      GO TO 120
+*
+*        Now the active submatrix is in rows and columns L to I. If
+*        eigenvalues only are being computed, only the active submatrix
+*        need be transformed.
+*
+         IF( .NOT.WANTT ) THEN
+            I1 = L
+            I2 = I
+         END IF
+*
+         IF( ITS.EQ.10 .OR. ITS.EQ.20 ) THEN
+*
+*           Exceptional shift.
+*
+            T = ABS( REAL( H( I, I-1 ) ) ) +
+     $          ABS( REAL( H( I-1, I-2 ) ) )
+         ELSE
+*
+*           Wilkinson's shift.
+*
+            T = H( I, I )
+            U = H( I-1, I )*REAL( H( I, I-1 ) )
+            IF( U.NE.ZERO ) THEN
+               X = HALF*( H( I-1, I-1 )-T )
+               Y = SQRT( X*X+U )
+               IF( REAL( X )*REAL( Y )+AIMAG( X )*AIMAG( Y ).LT.RZERO )
+     $            Y = -Y
+               T = T - CLADIV( U, ( X+Y ) )
+            END IF
+         END IF
+*
+*        Look for two consecutive small subdiagonal elements.
+*
+         DO 40 M = I - 1, L + 1, -1
+*
+*           Determine the effect of starting the single-shift QR
+*           iteration at row M, and see if this would make H(M,M-1)
+*           negligible.
+*
+            H11 = H( M, M )
+            H22 = H( M+1, M+1 )
+            H11S = H11 - T
+            H21 = H( M+1, M )
+            S = CABS1( H11S ) + ABS( H21 )
+            H11S = H11S / S
+            H21 = H21 / S
+            V( 1 ) = H11S
+            V( 2 ) = H21
+            H10 = H( M, M-1 )
+            TST1 = CABS1( H11S )*( CABS1( H11 )+CABS1( H22 ) )
+            IF( ABS( H10*H21 ).LE.ULP*TST1 )
+     $         GO TO 50
+   40    CONTINUE
+         H11 = H( L, L )
+         H22 = H( L+1, L+1 )
+         H11S = H11 - T
+         H21 = H( L+1, L )
+         S = CABS1( H11S ) + ABS( H21 )
+         H11S = H11S / S
+         H21 = H21 / S
+         V( 1 ) = H11S
+         V( 2 ) = H21
+   50    CONTINUE
+*
+*        Single-shift QR step
+*
+         DO 100 K = M, I - 1
+*
+*           The first iteration of this loop determines a reflection G
+*           from the vector V and applies it from left and right to H,
+*           thus creating a nonzero bulge below the subdiagonal.
+*
+*           Each subsequent iteration determines a reflection G to
+*           restore the Hessenberg form in the (K-1)th column, and thus
+*           chases the bulge one step toward the bottom of the active
+*           submatrix.
+*
+*           V(2) is always real before the call to CLARFG, and hence
+*           after the call T2 ( = T1*V(2) ) is also real.
+*
+            IF( K.GT.M )
+     $         CALL CCOPY( 2, H( K, K-1 ), 1, V, 1 )
+            CALL CLARFG( 2, V( 1 ), V( 2 ), 1, T1 )
+            IF( K.GT.M ) THEN
+               H( K, K-1 ) = V( 1 )
+               H( K+1, K-1 ) = ZERO
+            END IF
+            V2 = V( 2 )
+            T2 = REAL( T1*V2 )
+*
+*           Apply G from the left to transform the rows of the matrix
+*           in columns K to I2.
+*
+            DO 60 J = K, I2
+               SUM = CONJG( T1 )*H( K, J ) + T2*H( K+1, J )
+               H( K, J ) = H( K, J ) - SUM
+               H( K+1, J ) = H( K+1, J ) - SUM*V2
+   60       CONTINUE
+*
+*           Apply G from the right to transform the columns of the
+*           matrix in rows I1 to min(K+2,I).
+*
+            DO 70 J = I1, MIN( K+2, I )
+               SUM = T1*H( J, K ) + T2*H( J, K+1 )
+               H( J, K ) = H( J, K ) - SUM
+               H( J, K+1 ) = H( J, K+1 ) - SUM*CONJG( V2 )
+   70       CONTINUE
+*
+            IF( WANTZ ) THEN
+*
+*              Accumulate transformations in the matrix Z
+*
+               DO 80 J = ILOZ, IHIZ
+                  SUM = T1*Z( J, K ) + T2*Z( J, K+1 )
+                  Z( J, K ) = Z( J, K ) - SUM
+                  Z( J, K+1 ) = Z( J, K+1 ) - SUM*CONJG( V2 )
+   80          CONTINUE
+            END IF
+*
+            IF( K.EQ.M .AND. M.GT.L ) THEN
+*
+*              If the QR step was started at row M > L because two
+*              consecutive small subdiagonals were found, then extra
+*              scaling must be performed to ensure that H(M,M-1) remains
+*              real.
+*
+               TEMP = ONE - T1
+               TEMP = TEMP / ABS( TEMP )
+               H( M+1, M ) = H( M+1, M )*CONJG( TEMP )
+               IF( M+2.LE.I )
+     $            H( M+2, M+1 ) = H( M+2, M+1 )*TEMP
+               DO 90 J = M, I
+                  IF( J.NE.M+1 ) THEN
+                     IF( I2.GT.J )
+     $                  CALL CSCAL( I2-J, TEMP, H( J, J+1 ), LDH )
+                     CALL CSCAL( J-I1, CONJG( TEMP ), H( I1, J ), 1 )
+                     IF( WANTZ ) THEN
+                        CALL CSCAL( NZ, CONJG( TEMP ), Z( ILOZ, J ), 1 )
+                     END IF
+                  END IF
+   90          CONTINUE
+            END IF
+  100    CONTINUE
+*
+*        Ensure that H(I,I-1) is real.
+*
+         TEMP = H( I, I-1 )
+         IF( AIMAG( TEMP ).NE.RZERO ) THEN
+            RTEMP = ABS( TEMP )
+            H( I, I-1 ) = RTEMP
+            TEMP = TEMP / RTEMP
+            IF( I2.GT.I )
+     $         CALL CSCAL( I2-I, CONJG( TEMP ), H( I, I+1 ), LDH )
+            CALL CSCAL( I-I1, TEMP, H( I1, I ), 1 )
+            IF( WANTZ ) THEN
+               CALL CSCAL( NZ, TEMP, Z( ILOZ, I ), 1 )
+            END IF
+         END IF
+*
+  110 CONTINUE
+*
+*     Failure to converge in remaining number of iterations
+*
+      INFO = I
+      RETURN
+*
+  120 CONTINUE
+*
+*     H(I,I-1) is negligible: one eigenvalue has converged.
+*
+      W( I ) = H( I, I )
+*
+*     Decrement number of remaining iterations, and return to start of
+*     the main loop with new value of I.
+*
+      ITN = ITN - ITS
+      I = L - 1
+      GO TO 10
+*
+  130 CONTINUE
+      RETURN
+*
+*     End of CLAHQR
+*
+      END
+
+
+
diff -rupN SRC-old/cnaitr.f SRC/cnaitr.f
--- SRC-old/cnaitr.f	2014-06-01 16:07:19.000000000 +0530
+++ SRC/cnaitr.f	2014-06-01 16:07:38.000000000 +0530
@@ -308,7 +308,7 @@ c        | Set machine-dependent constan
 c        | the splitting and deflation criterion.  |
 c        | If norm(H) <= sqrt(OVFL),               |
 c        | overflow should not occur.              |
-c        | REFERENCE: LAPACK subroutine clahqr     |
+c        | REFERENCE: LAPACK subroutine clahqr2     |
 c        %-----------------------------------------%
 c
          unfl = slamch( 'safe minimum' )
@@ -808,7 +808,7 @@ c     
 c              %--------------------------------------------%
 c              | Check for splitting and deflation.         |
 c              | Use a standard test as in the QR algorithm |
-c              | REFERENCE: LAPACK subroutine clahqr        |
+c              | REFERENCE: LAPACK subroutine clahqr2        |
 c              %--------------------------------------------%
 c     
                tst1 = slapy2(real(h(i,i)),aimag(h(i,i)))
diff -rupN SRC-old/cnapps.f SRC/cnapps.f
--- SRC-old/cnapps.f	2014-06-01 16:07:19.000000000 +0530
+++ SRC/cnapps.f	2014-06-01 16:07:38.000000000 +0530
@@ -122,7 +122,7 @@ c
 c\Remarks
 c  1. In this version, each shift is applied to all the sublocks of
 c     the Hessenberg matrix H and not just to the submatrix that it
-c     comes from. Deflation as in LAPACK routine clahqr (QR algorithm
+c     comes from. Deflation as in LAPACK routine clahqr2 (QR algorithm
 c     for upper Hessenberg matrices ) is used.
 c     Upon output, the subdiagonals of H are enforced to be non-negative
 c     real numbers.
@@ -224,7 +224,7 @@ c        %------------------------------
 c        | Set machine-dependent constants for the       |
 c        | stopping criterion. If norm(H) <= sqrt(OVFL), |
 c        | overflow should not occur.                    |
-c        | REFERENCE: LAPACK subroutine clahqr           |
+c        | REFERENCE: LAPACK subroutine clahqr2           |
 c        %-----------------------------------------------%
 c
          unfl = slamch( 'safe minimum' )
@@ -282,7 +282,7 @@ c
 c           %----------------------------------------%
 c           | Check for splitting and deflation. Use |
 c           | a standard test as in the QR algorithm |
-c           | REFERENCE: LAPACK subroutine clahqr    |
+c           | REFERENCE: LAPACK subroutine clahqr2    |
 c           %----------------------------------------%
 c
             tst1 = cabs1( h( i, i ) ) + cabs1( h( i+1, i+1 ) )
@@ -419,7 +419,7 @@ c
 c        %--------------------------------------------%
 c        | Final check for splitting and deflation.   |
 c        | Use a standard test as in the QR algorithm |
-c        | REFERENCE: LAPACK subroutine clahqr.       |
+c        | REFERENCE: LAPACK subroutine clahqr2.       |
 c        | Note: Since the subdiagonals of the        |
 c        | compressed H are nonnegative real numbers, |
 c        | we take advantage of this.                 |
diff -rupN SRC-old/cneigh.f SRC/cneigh.f
--- SRC-old/cneigh.f	2014-06-01 16:07:19.000000000 +0530
+++ SRC/cneigh.f	2014-06-01 16:07:38.000000000 +0530
@@ -51,7 +51,7 @@ c          Private (replicated) array on
 c          the front end. 
 c
 c  IERR    Integer.  (OUTPUT)
-c          Error exit flag from clahqr or ctrevc.
+c          Error exit flag from clahqr2 or ctrevc.
 c
 c\EndDoc
 c
@@ -69,7 +69,7 @@ c     cmout   ARPACK utility routine tha
 c     cvout   ARPACK utility routine that prints vectors.
 c     svout   ARPACK utility routine that prints vectors.
 c     clacpy  LAPACK matrix copy routine.
-c     clahqr  LAPACK routine to compute the Schur form of an
+c     clahqr2  LAPACK routine to compute the Schur form of an
 c             upper Hessenberg matrix.
 c     claset  LAPACK matrix initialization routine.
 c     ctrevc  LAPACK routine to compute the eigenvectors of a matrix
@@ -151,7 +151,7 @@ c     %----------------------%
 c     | External Subroutines |
 c     %----------------------%
 c
-      external   clacpy, clahqr, ctrevc, ccopy, 
+      external   clacpy, clahqr2, ctrevc, ccopy, 
      &           csscal, cmout, cvout, arscnd
 c
 c     %--------------------%
@@ -183,13 +183,13 @@ c     %---------------------------------
 c     | 1. Compute the eigenvalues, the last components of the   |
 c     |    corresponding Schur vectors and the full Schur form T |
 c     |    of the current upper Hessenberg matrix H.             |
-c     |    clahqr returns the full Schur form of H               | 
+c     |    clahqr2 returns the full Schur form of H               | 
 c     |    in WORKL(1:N**2), and the Schur vectors in q.         |
 c     %----------------------------------------------------------%
 c
       call clacpy ('All', n, n, h, ldh, workl, n)
       call claset ('All', n, n, zero, one, q, ldq)
-      call clahqr (.true., .true., n, 1, n, workl, ldh, ritz,
+      call clahqr2 (.true., .true., n, 1, n, workl, ldh, ritz,
      &             1, n, q, ldq, ierr)
       if (ierr .ne. 0) go to 9000
 c
diff -rupN SRC-old/cneupd.f SRC/cneupd.f
--- SRC-old/cneupd.f	2014-06-01 16:07:19.000000000 +0530
+++ SRC/cneupd.f	2014-06-01 16:07:38.000000000 +0530
@@ -201,7 +201,7 @@ c     cvout   ARPACK utility routine tha
 c     cgeqr2  LAPACK routine that computes the QR factorization of 
 c             a matrix.
 c     clacpy  LAPACK matrix copy routine.
-c     clahqr  LAPACK routine that computes the Schur form of a
+c     clahqr2  LAPACK routine that computes the Schur form of a
 c             upper Hessenberg matrix.
 c     claset  LAPACK matrix initialization routine.
 c     ctrevc  LAPACK routine to compute the eigenvectors of a matrix
@@ -314,7 +314,7 @@ c     %----------------------%
 c
       external   ccopy , cgeru, cgeqr2, clacpy, cmout,
      &           cunm2r, ctrmm, cvout, ivout,
-     &           clahqr
+     &           clahqr2
 c  
 c     %--------------------%
 c     | External Functions |
@@ -548,7 +548,7 @@ c
          end if
 c
 c        %-------------------------------------------------------%
-c        | Call LAPACK routine clahqr to compute the Schur form |
+c        | Call LAPACK routine clahqr2 to compute the Schur form |
 c        | of the upper Hessenberg matrix returned by CNAUPD.   |
 c        | Make a copy of the upper Hessenberg matrix.           |
 c        | Initialize the Schur vector matrix Q to the identity. |
@@ -558,7 +558,7 @@ c
          call claset('All', ncv, ncv          , 
      &                zero , one, workl(invsub),
      &                ldq)
-         call clahqr(.true., .true.       , ncv          , 
+         call clahqr2(.true., .true.       , ncv          , 
      &                1     , ncv          , workl(iuptri),
      &                ldh   , workl(iheig) , 1            ,
      &                ncv   , workl(invsub), ldq          ,
diff -rupN SRC-old/dlahqr2.f SRC/dlahqr2.f
--- SRC-old/dlahqr2.f	1970-01-01 05:30:00.000000000 +0530
+++ SRC/dlahqr2.f	2014-06-01 16:07:38.000000000 +0530
@@ -0,0 +1,410 @@
+      SUBROUTINE DLAHQR2( WANTT, WANTZ, N, ILO, IHI, H, LDH, WR, WI,
+     $                   ILOZ, IHIZ, Z, LDZ, INFO )
+*
+*  -- LAPACK auxiliary routine (version 2.0) --
+*     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
+*     Courant Institute, Argonne National Lab, and Rice University
+*     October 31, 1992
+*
+*     .. Scalar Arguments ..
+      LOGICAL            WANTT, WANTZ
+      INTEGER            IHI, IHIZ, ILO, ILOZ, INFO, LDH, LDZ, N
+*     ..
+*     .. Array Arguments ..
+      DOUBLE PRECISION   H( LDH, * ), WI( * ), WR( * ), Z( LDZ, * )
+*     ..
+*
+*  Purpose
+*  =======
+*
+*  DLAHQR is an auxiliary routine called by DHSEQR to update the
+*  eigenvalues and Schur decomposition already computed by DHSEQR, by
+*  dealing with the Hessenberg submatrix in rows and columns ILO to IHI.
+*
+*  Arguments
+*  =========
+*
+*  WANTT   (input) LOGICAL
+*          = .TRUE. : the full Schur form T is required;
+*          = .FALSE.: only eigenvalues are required.
+*
+*  WANTZ   (input) LOGICAL
+*          = .TRUE. : the matrix of Schur vectors Z is required;
+*          = .FALSE.: Schur vectors are not required.
+*
+*  N       (input) INTEGER
+*          The order of the matrix H.  N >= 0.
+*
+*  ILO     (input) INTEGER
+*  IHI     (input) INTEGER
+*          It is assumed that H is already upper quasi-triangular in
+*          rows and columns IHI+1:N, and that H(ILO,ILO-1) = 0 (unless
+*          ILO = 1). DLAHQR works primarily with the Hessenberg
+*          submatrix in rows and columns ILO to IHI, but applies
+*          transformations to all of H if WANTT is .TRUE..
+*          1 <= ILO <= max(1,IHI); IHI <= N.
+*
+*  H       (input/output) DOUBLE PRECISION array, dimension (LDH,N)
+*          On entry, the upper Hessenberg matrix H.
+*          On exit, if WANTT is .TRUE., H is upper quasi-triangular in
+*          rows and columns ILO:IHI, with any 2-by-2 diagonal blocks in
+*          standard form. If WANTT is .FALSE., the contents of H are
+*          unspecified on exit.
+*
+*  LDH     (input) INTEGER
+*          The leading dimension of the array H. LDH >= max(1,N).
+*
+*  WR      (output) DOUBLE PRECISION array, dimension (N)
+*  WI      (output) DOUBLE PRECISION array, dimension (N)
+*          The real and imaginary parts, respectively, of the computed
+*          eigenvalues ILO to IHI are stored in the corresponding
+*          elements of WR and WI. If two eigenvalues are computed as a
+*          complex conjugate pair, they are stored in consecutive
+*          elements of WR and WI, say the i-th and (i+1)th, with
+*          WI(i) > 0 and WI(i+1) < 0. If WANTT is .TRUE., the
+*          eigenvalues are stored in the same order as on the diagonal
+*          of the Schur form returned in H, with WR(i) = H(i,i), and, if
+*          H(i:i+1,i:i+1) is a 2-by-2 diagonal block,
+*          WI(i) = sqrt(H(i+1,i)*H(i,i+1)) and WI(i+1) = -WI(i).
+*
+*  ILOZ    (input) INTEGER
+*  IHIZ    (input) INTEGER
+*          Specify the rows of Z to which transformations must be
+*          applied if WANTZ is .TRUE..
+*          1 <= ILOZ <= ILO; IHI <= IHIZ <= N.
+*
+*  Z       (input/output) DOUBLE PRECISION array, dimension (LDZ,N)
+*          If WANTZ is .TRUE., on entry Z must contain the current
+*          matrix Z of transformations accumulated by DHSEQR, and on
+*          exit Z has been updated; transformations are applied only to
+*          the submatrix Z(ILOZ:IHIZ,ILO:IHI).
+*          If WANTZ is .FALSE., Z is not referenced.
+*
+*  LDZ     (input) INTEGER
+*          The leading dimension of the array Z. LDZ >= max(1,N).
+*
+*  INFO    (output) INTEGER
+*          = 0: successful exit
+*          > 0: DLAHQR failed to compute all the eigenvalues ILO to IHI
+*               in a total of 30*(IHI-ILO+1) iterations; if INFO = i,
+*               elements i+1:ihi of WR and WI contain those eigenvalues
+*               which have been successfully computed.
+*
+*  =====================================================================
+*
+*     .. Parameters ..
+      DOUBLE PRECISION   ZERO, ONE
+      PARAMETER          ( ZERO = 0.0D+0, ONE = 1.0D+0 )
+      DOUBLE PRECISION   DAT1, DAT2
+      PARAMETER          ( DAT1 = 0.75D+0, DAT2 = -0.4375D+0 )
+*     ..
+*     .. Local Scalars ..
+      INTEGER            I, I1, I2, ITN, ITS, J, K, L, M, NH, NR, NZ
+      DOUBLE PRECISION   CS, H00, H10, H11, H12, H21, H22, H33, H33S,
+     $                   H43H34, H44, H44S, OVFL, S, SMLNUM, SN, SUM,
+     $                   T1, T2, T3, TST1, ULP, UNFL, V1, V2, V3
+*     ..
+*     .. Local Arrays ..
+      DOUBLE PRECISION   V( 3 ), WORK( 1 )
+*     ..
+*     .. External Functions ..
+      DOUBLE PRECISION   DLAMCH, DLANHS
+      EXTERNAL           DLAMCH, DLANHS
+*     ..
+*     .. External Subroutines ..
+      EXTERNAL           DCOPY, DLABAD, DLANV2, DLARFG, DROT
+*     ..
+*     .. Intrinsic Functions ..
+      INTRINSIC          ABS, MAX, MIN
+*     ..
+*     .. Executable Statements ..
+*
+      INFO = 0
+*
+*     Quick return if possible
+*
+      IF( N.EQ.0 )
+     $   RETURN
+      IF( ILO.EQ.IHI ) THEN
+         WR( ILO ) = H( ILO, ILO )
+         WI( ILO ) = ZERO
+         RETURN
+      END IF
+*
+      NH = IHI - ILO + 1
+      NZ = IHIZ - ILOZ + 1
+*
+*     Set machine-dependent constants for the stopping criterion.
+*     If norm(H) <= sqrt(OVFL), overflow should not occur.
+*
+      UNFL = DLAMCH( 'Safe minimum' )
+      OVFL = ONE / UNFL
+      CALL DLABAD( UNFL, OVFL )
+      ULP = DLAMCH( 'Precision' )
+      SMLNUM = UNFL*( NH / ULP )
+*
+*     I1 and I2 are the indices of the first row and last column of H
+*     to which transformations must be applied. If eigenvalues only are
+*     being computed, I1 and I2 are set inside the main loop.
+*
+      IF( WANTT ) THEN
+         I1 = 1
+         I2 = N
+      END IF
+*
+*     ITN is the total number of QR iterations allowed.
+*
+      ITN = 30*NH
+*
+*     The main loop begins here. I is the loop index and decreases from
+*     IHI to ILO in steps of 1 or 2. Each iteration of the loop works
+*     with the active submatrix in rows and columns L to I.
+*     Eigenvalues I+1 to IHI have already converged. Either L = ILO or
+*     H(L,L-1) is negligible so that the matrix splits.
+*
+      I = IHI
+   10 CONTINUE
+      L = ILO
+      IF( I.LT.ILO )
+     $   GO TO 150
+*
+*     Perform QR iterations on rows and columns ILO to I until a
+*     submatrix of order 1 or 2 splits off at the bottom because a
+*     subdiagonal element has become negligible.
+*
+      DO 130 ITS = 0, ITN
+*
+*        Look for a single small subdiagonal element.
+*
+         DO 20 K = I, L + 1, -1
+            TST1 = ABS( H( K-1, K-1 ) ) + ABS( H( K, K ) )
+            IF( TST1.EQ.ZERO )
+     $         TST1 = DLANHS( '1', I-L+1, H( L, L ), LDH, WORK )
+            IF( ABS( H( K, K-1 ) ).LE.MAX( ULP*TST1, SMLNUM ) )
+     $         GO TO 30
+   20    CONTINUE
+   30    CONTINUE
+         L = K
+         IF( L.GT.ILO ) THEN
+*
+*           H(L,L-1) is negligible
+*
+            H( L, L-1 ) = ZERO
+         END IF
+*
+*        Exit from loop if a submatrix of order 1 or 2 has split off.
+*
+         IF( L.GE.I-1 )
+     $      GO TO 140
+*
+*        Now the active submatrix is in rows and columns L to I. If
+*        eigenvalues only are being computed, only the active submatrix
+*        need be transformed.
+*
+         IF( .NOT.WANTT ) THEN
+            I1 = L
+            I2 = I
+         END IF
+*
+         IF( ITS.EQ.10 .OR. ITS.EQ.20 ) THEN
+*
+*           Exceptional shift.
+*
+            S = ABS( H( I, I-1 ) ) + ABS( H( I-1, I-2 ) )
+            H44 = DAT1*S
+            H33 = H44
+            H43H34 = DAT2*S*S
+         ELSE
+*
+*           Prepare to use Wilkinson's double shift
+*
+            H44 = H( I, I )
+            H33 = H( I-1, I-1 )
+            H43H34 = H( I, I-1 )*H( I-1, I )
+         END IF
+*
+*        Look for two consecutive small subdiagonal elements.
+*
+         DO 40 M = I - 2, L, -1
+*
+*           Determine the effect of starting the double-shift QR
+*           iteration at row M, and see if this would make H(M,M-1)
+*           negligible.
+*
+            H11 = H( M, M )
+            H22 = H( M+1, M+1 )
+            H21 = H( M+1, M )
+            H12 = H( M, M+1 )
+            H44S = H44 - H11
+            H33S = H33 - H11
+            V1 = ( H33S*H44S-H43H34 ) / H21 + H12
+            V2 = H22 - H11 - H33S - H44S
+            V3 = H( M+2, M+1 )
+            S = ABS( V1 ) + ABS( V2 ) + ABS( V3 )
+            V1 = V1 / S
+            V2 = V2 / S
+            V3 = V3 / S
+            V( 1 ) = V1
+            V( 2 ) = V2
+            V( 3 ) = V3
+            IF( M.EQ.L )
+     $         GO TO 50
+            H00 = H( M-1, M-1 )
+            H10 = H( M, M-1 )
+            TST1 = ABS( V1 )*( ABS( H00 )+ABS( H11 )+ABS( H22 ) )
+            IF( ABS( H10 )*( ABS( V2 )+ABS( V3 ) ).LE.ULP*TST1 )
+     $         GO TO 50
+   40    CONTINUE
+   50    CONTINUE
+*
+*        Double-shift QR step
+*
+         DO 120 K = M, I - 1
+*
+*           The first iteration of this loop determines a reflection G
+*           from the vector V and applies it from left and right to H,
+*           thus creating a nonzero bulge below the subdiagonal.
+*
+*           Each subsequent iteration determines a reflection G to
+*           restore the Hessenberg form in the (K-1)th column, and thus
+*           chases the bulge one step toward the bottom of the active
+*           submatrix. NR is the order of G.
+*
+            NR = MIN( 3, I-K+1 )
+            IF( K.GT.M )
+     $         CALL DCOPY( NR, H( K, K-1 ), 1, V, 1 )
+            CALL DLARFG( NR, V( 1 ), V( 2 ), 1, T1 )
+            IF( K.GT.M ) THEN
+               H( K, K-1 ) = V( 1 )
+               H( K+1, K-1 ) = ZERO
+               IF( K.LT.I-1 )
+     $            H( K+2, K-1 ) = ZERO
+            ELSE IF( M.GT.L ) THEN
+               H( K, K-1 ) = -H( K, K-1 )
+            END IF
+            V2 = V( 2 )
+            T2 = T1*V2
+            IF( NR.EQ.3 ) THEN
+               V3 = V( 3 )
+               T3 = T1*V3
+*
+*              Apply G from the left to transform the rows of the matrix
+*              in columns K to I2.
+*
+               DO 60 J = K, I2
+                  SUM = H( K, J ) + V2*H( K+1, J ) + V3*H( K+2, J )
+                  H( K, J ) = H( K, J ) - SUM*T1
+                  H( K+1, J ) = H( K+1, J ) - SUM*T2
+                  H( K+2, J ) = H( K+2, J ) - SUM*T3
+   60          CONTINUE
+*
+*              Apply G from the right to transform the columns of the
+*              matrix in rows I1 to min(K+3,I).
+*
+               DO 70 J = I1, MIN( K+3, I )
+                  SUM = H( J, K ) + V2*H( J, K+1 ) + V3*H( J, K+2 )
+                  H( J, K ) = H( J, K ) - SUM*T1
+                  H( J, K+1 ) = H( J, K+1 ) - SUM*T2
+                  H( J, K+2 ) = H( J, K+2 ) - SUM*T3
+   70          CONTINUE
+*
+               IF( WANTZ ) THEN
+*
+*                 Accumulate transformations in the matrix Z
+*
+                  DO 80 J = ILOZ, IHIZ
+                     SUM = Z( J, K ) + V2*Z( J, K+1 ) + V3*Z( J, K+2 )
+                     Z( J, K ) = Z( J, K ) - SUM*T1
+                     Z( J, K+1 ) = Z( J, K+1 ) - SUM*T2
+                     Z( J, K+2 ) = Z( J, K+2 ) - SUM*T3
+   80             CONTINUE
+               END IF
+            ELSE IF( NR.EQ.2 ) THEN
+*
+*              Apply G from the left to transform the rows of the matrix
+*              in columns K to I2.
+*
+               DO 90 J = K, I2
+                  SUM = H( K, J ) + V2*H( K+1, J )
+                  H( K, J ) = H( K, J ) - SUM*T1
+                  H( K+1, J ) = H( K+1, J ) - SUM*T2
+   90          CONTINUE
+*
+*              Apply G from the right to transform the columns of the
+*              matrix in rows I1 to min(K+3,I).
+*
+               DO 100 J = I1, I
+                  SUM = H( J, K ) + V2*H( J, K+1 )
+                  H( J, K ) = H( J, K ) - SUM*T1
+                  H( J, K+1 ) = H( J, K+1 ) - SUM*T2
+  100          CONTINUE
+*
+               IF( WANTZ ) THEN
+*
+*                 Accumulate transformations in the matrix Z
+*
+                  DO 110 J = ILOZ, IHIZ
+                     SUM = Z( J, K ) + V2*Z( J, K+1 )
+                     Z( J, K ) = Z( J, K ) - SUM*T1
+                     Z( J, K+1 ) = Z( J, K+1 ) - SUM*T2
+  110             CONTINUE
+               END IF
+            END IF
+  120    CONTINUE
+*
+  130 CONTINUE
+*
+*     Failure to converge in remaining number of iterations
+*
+      INFO = I
+      RETURN
+*
+  140 CONTINUE
+*
+      IF( L.EQ.I ) THEN
+*
+*        H(I,I-1) is negligible: one eigenvalue has converged.
+*
+         WR( I ) = H( I, I )
+         WI( I ) = ZERO
+      ELSE IF( L.EQ.I-1 ) THEN
+*
+*        H(I-1,I-2) is negligible: a pair of eigenvalues have converged.
+*
+*        Transform the 2-by-2 submatrix to standard Schur form,
+*        and compute and store the eigenvalues.
+*
+         CALL DLANV2( H( I-1, I-1 ), H( I-1, I ), H( I, I-1 ),
+     $                H( I, I ), WR( I-1 ), WI( I-1 ), WR( I ), WI( I ),
+     $                CS, SN )
+*
+         IF( WANTT ) THEN
+*
+*           Apply the transformation to the rest of H.
+*
+            IF( I2.GT.I )
+     $         CALL DROT( I2-I, H( I-1, I+1 ), LDH, H( I, I+1 ), LDH,
+     $                    CS, SN )
+            CALL DROT( I-I1-1, H( I1, I-1 ), 1, H( I1, I ), 1, CS, SN )
+         END IF
+         IF( WANTZ ) THEN
+*
+*           Apply the transformation to Z.
+*
+            CALL DROT( NZ, Z( ILOZ, I-1 ), 1, Z( ILOZ, I ), 1, CS, SN )
+         END IF
+      END IF
+*
+*     Decrement number of remaining iterations, and return to start of
+*     the main loop with new value of I.
+*
+      ITN = ITN - ITS
+      I = L - 1
+      GO TO 10
+*
+  150 CONTINUE
+      RETURN
+*
+*     End of DLAHQR
+*
+      END
diff -rupN SRC-old/dlaqrb.f SRC/dlaqrb.f
--- SRC-old/dlaqrb.f	2014-06-01 16:07:19.000000000 +0530
+++ SRC/dlaqrb.f	2014-06-01 16:07:38.000000000 +0530
@@ -8,7 +8,7 @@ c  Compute the eigenvalues and the Schur
 c  Hessenberg submatrix in rows and columns ILO to IHI.  Only the
 c  last component of the Schur vectors are computed.
 c
-c  This is mostly a modification of the LAPACK routine dlahqr.
+c  This is mostly a modification of the LAPACK routine dlahqr2.
 c  
 c\Usage:
 c  call dlaqrb
@@ -95,7 +95,7 @@ c     Houston, Texas            
 c
 c\Revision history:
 c     xx/xx/92: Version ' 2.4'
-c               Modified from the LAPACK routine dlahqr so that only the
+c               Modified from the LAPACK routine dlahqr2 so that only the
 c               last component of the Schur vectors are computed.
 c
 c\SCCS Information: @(#) 
diff -rupN SRC-old/dnaitr.f SRC/dnaitr.f
--- SRC-old/dnaitr.f	2014-06-01 16:07:19.000000000 +0530
+++ SRC/dnaitr.f	2014-06-01 16:07:38.000000000 +0530
@@ -301,7 +301,7 @@ c        | Set machine-dependent constan
 c        | the splitting and deflation criterion.  |
 c        | If norm(H) <= sqrt(OVFL),               |
 c        | overflow should not occur.              |
-c        | REFERENCE: LAPACK subroutine dlahqr     |
+c        | REFERENCE: LAPACK subroutine dlahqr2     |
 c        %-----------------------------------------%
 c
          unfl = dlamch( 'safe minimum' )
@@ -800,7 +800,7 @@ c     
 c              %--------------------------------------------%
 c              | Check for splitting and deflation.         |
 c              | Use a standard test as in the QR algorithm |
-c              | REFERENCE: LAPACK subroutine dlahqr        |
+c              | REFERENCE: LAPACK subroutine dlahqr2        |
 c              %--------------------------------------------%
 c     
                tst1 = abs( h( i, i ) ) + abs( h( i+1, i+1 ) )
diff -rupN SRC-old/dnapps.f SRC/dnapps.f
--- SRC-old/dnapps.f	2014-06-01 16:07:19.000000000 +0530
+++ SRC/dnapps.f	2014-06-01 16:07:38.000000000 +0530
@@ -132,7 +132,7 @@ c
 c\Remarks
 c  1. In this version, each shift is applied to all the sublocks of
 c     the Hessenberg matrix H and not just to the submatrix that it
-c     comes from. Deflation as in LAPACK routine dlahqr (QR algorithm
+c     comes from. Deflation as in LAPACK routine dlahqr2 (QR algorithm
 c     for upper Hessenberg matrices ) is used.
 c     The subdiagonals of H are enforced to be non-negative.
 c
@@ -221,7 +221,7 @@ c        %------------------------------
 c        | Set machine-dependent constants for the       |
 c        | stopping criterion. If norm(H) <= sqrt(OVFL), |
 c        | overflow should not occur.                    |
-c        | REFERENCE: LAPACK subroutine dlahqr           |
+c        | REFERENCE: LAPACK subroutine dlahqr2           |
 c        %-----------------------------------------------%
 c
          unfl = dlamch( 'safe minimum' )
@@ -327,7 +327,7 @@ c
 c           %----------------------------------------%
 c           | Check for splitting and deflation. Use |
 c           | a standard test as in the QR algorithm |
-c           | REFERENCE: LAPACK subroutine dlahqr    |
+c           | REFERENCE: LAPACK subroutine dlahqr2    |
 c           %----------------------------------------%
 c
             tst1 = abs( h( i, i ) ) + abs( h( i+1, i+1 ) )
@@ -562,7 +562,7 @@ c
 c        %--------------------------------------------%
 c        | Final check for splitting and deflation.   |
 c        | Use a standard test as in the QR algorithm |
-c        | REFERENCE: LAPACK subroutine dlahqr        |
+c        | REFERENCE: LAPACK subroutine dlahqr2        |
 c        %--------------------------------------------%
 c
          tst1 = abs( h( i, i ) ) + abs( h( i+1, i+1 ) )
diff -rupN SRC-old/dneupd.f SRC/dneupd.f
--- SRC-old/dneupd.f	2014-06-01 16:07:19.000000000 +0530
+++ SRC/dneupd.f	2014-06-01 16:07:38.000000000 +0530
@@ -181,7 +181,7 @@ c          Error flag on output.
 c
 c          =  0: Normal exit.
 c
-c          =  1: The Schur form computed by LAPACK routine dlahqr 
+c          =  1: The Schur form computed by LAPACK routine dlahqr2 
 c                could not be reordered by LAPACK routine dtrsen .
 c                Re-enter subroutine dneupd  with IPARAM(5)=NCV and 
 c                increase the size of the arrays DR and DI to have 
@@ -197,7 +197,7 @@ c          = -5: WHICH must be one of 'L
 c          = -6: BMAT must be one of 'I' or 'G'.
 c          = -7: Length of private work WORKL array is not sufficient.
 c          = -8: Error return from calculation of a real Schur form.
-c                Informational error from LAPACK routine dlahqr .
+c                Informational error from LAPACK routine dlahqr2 .
 c          = -9: Error return from calculation of eigenvectors.
 c                Informational error from LAPACK routine dtrevc .
 c          = -10: IPARAM(7) must be 1,2,3,4.
@@ -232,7 +232,7 @@ c     dvout    ARPACK utility routine th
 c     dgeqr2   LAPACK routine that computes the QR factorization of 
 c             a matrix.
 c     dlacpy   LAPACK matrix copy routine.
-c     dlahqr   LAPACK routine to compute the real Schur form of an
+c     dlahqr2   LAPACK routine to compute the real Schur form of an
 c             upper Hessenberg matrix.
 c     dlamch   LAPACK routine that determines machine constants.
 c     dlapy2   LAPACK routine to compute sqrt(x**2+y**2) carefully.
@@ -364,7 +364,7 @@ c     | External Subroutines |
 c     %----------------------%
 c
       external   dcopy  , dger   , dgeqr2 , dlacpy , 
-     &           dlahqr , dlaset , dmout  , dorm2r , 
+     &           dlahqr2 , dlaset , dmout  , dorm2r , 
      &           dtrevc , dtrmm  , dtrsen , dscal  , 
      &           dvout  , ivout
 c
@@ -613,7 +613,7 @@ c
          end if
 c
 c        %-----------------------------------------------------------%
-c        | Call LAPACK routine dlahqr  to compute the real Schur form |
+c        | Call LAPACK routine dlahqr2  to compute the real Schur form |
 c        | of the upper Hessenberg matrix returned by DNAUPD .        |
 c        | Make a copy of the upper Hessenberg matrix.               |
 c        | Initialize the Schur vector matrix Q to the identity.     |
@@ -623,7 +623,7 @@ c     
          call dlaset ('All', ncv, ncv, 
      &                zero , one, workl(invsub),
      &                ldq)
-         call dlahqr (.true., .true.       , ncv, 
+         call dlahqr2 (.true., .true.       , ncv, 
      &                1     , ncv          , workl(iuptri), 
      &                ldh   , workl(iheigr), workl(iheigi),
      &                1     , ncv          , workl(invsub), 
diff -rupN SRC-old/slahqr2.f SRC/slahqr2.f
--- SRC-old/slahqr2.f	1970-01-01 05:30:00.000000000 +0530
+++ SRC/slahqr2.f	2014-06-01 16:07:38.000000000 +0530
@@ -0,0 +1,410 @@
+      SUBROUTINE SLAHQR2( WANTT, WANTZ, N, ILO, IHI, H, LDH, WR, WI,
+     $                   ILOZ, IHIZ, Z, LDZ, INFO )
+*
+*  -- LAPACK auxiliary routine (version 2.0) --
+*     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
+*     Courant Institute, Argonne National Lab, and Rice University
+*     October 31, 1992
+*
+*     .. Scalar Arguments ..
+      LOGICAL            WANTT, WANTZ
+      INTEGER            IHI, IHIZ, ILO, ILOZ, INFO, LDH, LDZ, N
+*     ..
+*     .. Array Arguments ..
+      REAL               H( LDH, * ), WI( * ), WR( * ), Z( LDZ, * )
+*     ..
+*
+*  Purpose
+*  =======
+*
+*  SLAHQR is an auxiliary routine called by SHSEQR to update the
+*  eigenvalues and Schur decomposition already computed by SHSEQR, by
+*  dealing with the Hessenberg submatrix in rows and columns ILO to IHI.
+*
+*  Arguments
+*  =========
+*
+*  WANTT   (input) LOGICAL
+*          = .TRUE. : the full Schur form T is required;
+*          = .FALSE.: only eigenvalues are required.
+*
+*  WANTZ   (input) LOGICAL
+*          = .TRUE. : the matrix of Schur vectors Z is required;
+*          = .FALSE.: Schur vectors are not required.
+*
+*  N       (input) INTEGER
+*          The order of the matrix H.  N >= 0.
+*
+*  ILO     (input) INTEGER
+*  IHI     (input) INTEGER
+*          It is assumed that H is already upper quasi-triangular in
+*          rows and columns IHI+1:N, and that H(ILO,ILO-1) = 0 (unless
+*          ILO = 1). SLAHQR works primarily with the Hessenberg
+*          submatrix in rows and columns ILO to IHI, but applies
+*          transformations to all of H if WANTT is .TRUE..
+*          1 <= ILO <= max(1,IHI); IHI <= N.
+*
+*  H       (input/output) REAL array, dimension (LDH,N)
+*          On entry, the upper Hessenberg matrix H.
+*          On exit, if WANTT is .TRUE., H is upper quasi-triangular in
+*          rows and columns ILO:IHI, with any 2-by-2 diagonal blocks in
+*          standard form. If WANTT is .FALSE., the contents of H are
+*          unspecified on exit.
+*
+*  LDH     (input) INTEGER
+*          The leading dimension of the array H. LDH >= max(1,N).
+*
+*  WR      (output) REAL array, dimension (N)
+*  WI      (output) REAL array, dimension (N)
+*          The real and imaginary parts, respectively, of the computed
+*          eigenvalues ILO to IHI are stored in the corresponding
+*          elements of WR and WI. If two eigenvalues are computed as a
+*          complex conjugate pair, they are stored in consecutive
+*          elements of WR and WI, say the i-th and (i+1)th, with
+*          WI(i) > 0 and WI(i+1) < 0. If WANTT is .TRUE., the
+*          eigenvalues are stored in the same order as on the diagonal
+*          of the Schur form returned in H, with WR(i) = H(i,i), and, if
+*          H(i:i+1,i:i+1) is a 2-by-2 diagonal block,
+*          WI(i) = sqrt(H(i+1,i)*H(i,i+1)) and WI(i+1) = -WI(i).
+*
+*  ILOZ    (input) INTEGER
+*  IHIZ    (input) INTEGER
+*          Specify the rows of Z to which transformations must be
+*          applied if WANTZ is .TRUE..
+*          1 <= ILOZ <= ILO; IHI <= IHIZ <= N.
+*
+*  Z       (input/output) REAL array, dimension (LDZ,N)
+*          If WANTZ is .TRUE., on entry Z must contain the current
+*          matrix Z of transformations accumulated by SHSEQR, and on
+*          exit Z has been updated; transformations are applied only to
+*          the submatrix Z(ILOZ:IHIZ,ILO:IHI).
+*          If WANTZ is .FALSE., Z is not referenced.
+*
+*  LDZ     (input) INTEGER
+*          The leading dimension of the array Z. LDZ >= max(1,N).
+*
+*  INFO    (output) INTEGER
+*          = 0: successful exit
+*          > 0: SLAHQR failed to compute all the eigenvalues ILO to IHI
+*               in a total of 30*(IHI-ILO+1) iterations; if INFO = i,
+*               elements i+1:ihi of WR and WI contain those eigenvalues
+*               which have been successfully computed.
+*
+*  =====================================================================
+*
+*     .. Parameters ..
+      REAL               ZERO, ONE
+      PARAMETER          ( ZERO = 0.0E+0, ONE = 1.0E+0 )
+      REAL               DAT1, DAT2
+      PARAMETER          ( DAT1 = 0.75E+0, DAT2 = -0.4375E+0 )
+*     ..
+*     .. Local Scalars ..
+      INTEGER            I, I1, I2, ITN, ITS, J, K, L, M, NH, NR, NZ
+      REAL               CS, H00, H10, H11, H12, H21, H22, H33, H33S,
+     $                   H43H34, H44, H44S, OVFL, S, SMLNUM, SN, SUM,
+     $                   T1, T2, T3, TST1, ULP, UNFL, V1, V2, V3
+*     ..
+*     .. Local Arrays ..
+      REAL               V( 3 ), WORK( 1 )
+*     ..
+*     .. External Functions ..
+      REAL               SLAMCH, SLANHS
+      EXTERNAL           SLAMCH, SLANHS
+*     ..
+*     .. External Subroutines ..
+      EXTERNAL           SCOPY, SLABAD, SLANV2, SLARFG, SROT
+*     ..
+*     .. Intrinsic Functions ..
+      INTRINSIC          ABS, MAX, MIN
+*     ..
+*     .. Executable Statements ..
+*
+      INFO = 0
+*
+*     Quick return if possible
+*
+      IF( N.EQ.0 )
+     $   RETURN
+      IF( ILO.EQ.IHI ) THEN
+         WR( ILO ) = H( ILO, ILO )
+         WI( ILO ) = ZERO
+         RETURN
+      END IF
+*
+      NH = IHI - ILO + 1
+      NZ = IHIZ - ILOZ + 1
+*
+*     Set machine-dependent constants for the stopping criterion.
+*     If norm(H) <= sqrt(OVFL), overflow should not occur.
+*
+      UNFL = SLAMCH( 'Safe minimum' )
+      OVFL = ONE / UNFL
+      CALL SLABAD( UNFL, OVFL )
+      ULP = SLAMCH( 'Precision' )
+      SMLNUM = UNFL*( NH / ULP )
+*
+*     I1 and I2 are the indices of the first row and last column of H
+*     to which transformations must be applied. If eigenvalues only are
+*     being computed, I1 and I2 are set inside the main loop.
+*
+      IF( WANTT ) THEN
+         I1 = 1
+         I2 = N
+      END IF
+*
+*     ITN is the total number of QR iterations allowed.
+*
+      ITN = 30*NH
+*
+*     The main loop begins here. I is the loop index and decreases from
+*     IHI to ILO in steps of 1 or 2. Each iteration of the loop works
+*     with the active submatrix in rows and columns L to I.
+*     Eigenvalues I+1 to IHI have already converged. Either L = ILO or
+*     H(L,L-1) is negligible so that the matrix splits.
+*
+      I = IHI
+   10 CONTINUE
+      L = ILO
+      IF( I.LT.ILO )
+     $   GO TO 150
+*
+*     Perform QR iterations on rows and columns ILO to I until a
+*     submatrix of order 1 or 2 splits off at the bottom because a
+*     subdiagonal element has become negligible.
+*
+      DO 130 ITS = 0, ITN
+*
+*        Look for a single small subdiagonal element.
+*
+         DO 20 K = I, L + 1, -1
+            TST1 = ABS( H( K-1, K-1 ) ) + ABS( H( K, K ) )
+            IF( TST1.EQ.ZERO )
+     $         TST1 = SLANHS( '1', I-L+1, H( L, L ), LDH, WORK )
+            IF( ABS( H( K, K-1 ) ).LE.MAX( ULP*TST1, SMLNUM ) )
+     $         GO TO 30
+   20    CONTINUE
+   30    CONTINUE
+         L = K
+         IF( L.GT.ILO ) THEN
+*
+*           H(L,L-1) is negligible
+*
+            H( L, L-1 ) = ZERO
+         END IF
+*
+*        Exit from loop if a submatrix of order 1 or 2 has split off.
+*
+         IF( L.GE.I-1 )
+     $      GO TO 140
+*
+*        Now the active submatrix is in rows and columns L to I. If
+*        eigenvalues only are being computed, only the active submatrix
+*        need be transformed.
+*
+         IF( .NOT.WANTT ) THEN
+            I1 = L
+            I2 = I
+         END IF
+*
+         IF( ITS.EQ.10 .OR. ITS.EQ.20 ) THEN
+*
+*           Exceptional shift.
+*
+            S = ABS( H( I, I-1 ) ) + ABS( H( I-1, I-2 ) )
+            H44 = DAT1*S
+            H33 = H44
+            H43H34 = DAT2*S*S
+         ELSE
+*
+*           Prepare to use Wilkinson's double shift
+*
+            H44 = H( I, I )
+            H33 = H( I-1, I-1 )
+            H43H34 = H( I, I-1 )*H( I-1, I )
+         END IF
+*
+*        Look for two consecutive small subdiagonal elements.
+*
+         DO 40 M = I - 2, L, -1
+*
+*           Determine the effect of starting the double-shift QR
+*           iteration at row M, and see if this would make H(M,M-1)
+*           negligible.
+*
+            H11 = H( M, M )
+            H22 = H( M+1, M+1 )
+            H21 = H( M+1, M )
+            H12 = H( M, M+1 )
+            H44S = H44 - H11
+            H33S = H33 - H11
+            V1 = ( H33S*H44S-H43H34 ) / H21 + H12
+            V2 = H22 - H11 - H33S - H44S
+            V3 = H( M+2, M+1 )
+            S = ABS( V1 ) + ABS( V2 ) + ABS( V3 )
+            V1 = V1 / S
+            V2 = V2 / S
+            V3 = V3 / S
+            V( 1 ) = V1
+            V( 2 ) = V2
+            V( 3 ) = V3
+            IF( M.EQ.L )
+     $         GO TO 50
+            H00 = H( M-1, M-1 )
+            H10 = H( M, M-1 )
+            TST1 = ABS( V1 )*( ABS( H00 )+ABS( H11 )+ABS( H22 ) )
+            IF( ABS( H10 )*( ABS( V2 )+ABS( V3 ) ).LE.ULP*TST1 )
+     $         GO TO 50
+   40    CONTINUE
+   50    CONTINUE
+*
+*        Double-shift QR step
+*
+         DO 120 K = M, I - 1
+*
+*           The first iteration of this loop determines a reflection G
+*           from the vector V and applies it from left and right to H,
+*           thus creating a nonzero bulge below the subdiagonal.
+*
+*           Each subsequent iteration determines a reflection G to
+*           restore the Hessenberg form in the (K-1)th column, and thus
+*           chases the bulge one step toward the bottom of the active
+*           submatrix. NR is the order of G.
+*
+            NR = MIN( 3, I-K+1 )
+            IF( K.GT.M )
+     $         CALL SCOPY( NR, H( K, K-1 ), 1, V, 1 )
+            CALL SLARFG( NR, V( 1 ), V( 2 ), 1, T1 )
+            IF( K.GT.M ) THEN
+               H( K, K-1 ) = V( 1 )
+               H( K+1, K-1 ) = ZERO
+               IF( K.LT.I-1 )
+     $            H( K+2, K-1 ) = ZERO
+            ELSE IF( M.GT.L ) THEN
+               H( K, K-1 ) = -H( K, K-1 )
+            END IF
+            V2 = V( 2 )
+            T2 = T1*V2
+            IF( NR.EQ.3 ) THEN
+               V3 = V( 3 )
+               T3 = T1*V3
+*
+*              Apply G from the left to transform the rows of the matrix
+*              in columns K to I2.
+*
+               DO 60 J = K, I2
+                  SUM = H( K, J ) + V2*H( K+1, J ) + V3*H( K+2, J )
+                  H( K, J ) = H( K, J ) - SUM*T1
+                  H( K+1, J ) = H( K+1, J ) - SUM*T2
+                  H( K+2, J ) = H( K+2, J ) - SUM*T3
+   60          CONTINUE
+*
+*              Apply G from the right to transform the columns of the
+*              matrix in rows I1 to min(K+3,I).
+*
+               DO 70 J = I1, MIN( K+3, I )
+                  SUM = H( J, K ) + V2*H( J, K+1 ) + V3*H( J, K+2 )
+                  H( J, K ) = H( J, K ) - SUM*T1
+                  H( J, K+1 ) = H( J, K+1 ) - SUM*T2
+                  H( J, K+2 ) = H( J, K+2 ) - SUM*T3
+   70          CONTINUE
+*
+               IF( WANTZ ) THEN
+*
+*                 Accumulate transformations in the matrix Z
+*
+                  DO 80 J = ILOZ, IHIZ
+                     SUM = Z( J, K ) + V2*Z( J, K+1 ) + V3*Z( J, K+2 )
+                     Z( J, K ) = Z( J, K ) - SUM*T1
+                     Z( J, K+1 ) = Z( J, K+1 ) - SUM*T2
+                     Z( J, K+2 ) = Z( J, K+2 ) - SUM*T3
+   80             CONTINUE
+               END IF
+            ELSE IF( NR.EQ.2 ) THEN
+*
+*              Apply G from the left to transform the rows of the matrix
+*              in columns K to I2.
+*
+               DO 90 J = K, I2
+                  SUM = H( K, J ) + V2*H( K+1, J )
+                  H( K, J ) = H( K, J ) - SUM*T1
+                  H( K+1, J ) = H( K+1, J ) - SUM*T2
+   90          CONTINUE
+*
+*              Apply G from the right to transform the columns of the
+*              matrix in rows I1 to min(K+3,I).
+*
+               DO 100 J = I1, I
+                  SUM = H( J, K ) + V2*H( J, K+1 )
+                  H( J, K ) = H( J, K ) - SUM*T1
+                  H( J, K+1 ) = H( J, K+1 ) - SUM*T2
+  100          CONTINUE
+*
+               IF( WANTZ ) THEN
+*
+*                 Accumulate transformations in the matrix Z
+*
+                  DO 110 J = ILOZ, IHIZ
+                     SUM = Z( J, K ) + V2*Z( J, K+1 )
+                     Z( J, K ) = Z( J, K ) - SUM*T1
+                     Z( J, K+1 ) = Z( J, K+1 ) - SUM*T2
+  110             CONTINUE
+               END IF
+            END IF
+  120    CONTINUE
+*
+  130 CONTINUE
+*
+*     Failure to converge in remaining number of iterations
+*
+      INFO = I
+      RETURN
+*
+  140 CONTINUE
+*
+      IF( L.EQ.I ) THEN
+*
+*        H(I,I-1) is negligible: one eigenvalue has converged.
+*
+         WR( I ) = H( I, I )
+         WI( I ) = ZERO
+      ELSE IF( L.EQ.I-1 ) THEN
+*
+*        H(I-1,I-2) is negligible: a pair of eigenvalues have converged.
+*
+*        Transform the 2-by-2 submatrix to standard Schur form,
+*        and compute and store the eigenvalues.
+*
+         CALL SLANV2( H( I-1, I-1 ), H( I-1, I ), H( I, I-1 ),
+     $                H( I, I ), WR( I-1 ), WI( I-1 ), WR( I ), WI( I ),
+     $                CS, SN )
+*
+         IF( WANTT ) THEN
+*
+*           Apply the transformation to the rest of H.
+*
+            IF( I2.GT.I )
+     $         CALL SROT( I2-I, H( I-1, I+1 ), LDH, H( I, I+1 ), LDH,
+     $                    CS, SN )
+            CALL SROT( I-I1-1, H( I1, I-1 ), 1, H( I1, I ), 1, CS, SN )
+         END IF
+         IF( WANTZ ) THEN
+*
+*           Apply the transformation to Z.
+*
+            CALL SROT( NZ, Z( ILOZ, I-1 ), 1, Z( ILOZ, I ), 1, CS, SN )
+         END IF
+      END IF
+*
+*     Decrement number of remaining iterations, and return to start of
+*     the main loop with new value of I.
+*
+      ITN = ITN - ITS
+      I = L - 1
+      GO TO 10
+*
+  150 CONTINUE
+      RETURN
+*
+*     End of SLAHQR
+*
+      END
diff -rupN SRC-old/slaqrb.f SRC/slaqrb.f
--- SRC-old/slaqrb.f	2014-06-01 16:07:19.000000000 +0530
+++ SRC/slaqrb.f	2014-06-01 16:07:38.000000000 +0530
@@ -8,7 +8,7 @@ c  Compute the eigenvalues and the Schur
 c  Hessenberg submatrix in rows and columns ILO to IHI.  Only the
 c  last component of the Schur vectors are computed.
 c
-c  This is mostly a modification of the LAPACK routine slahqr.
+c  This is mostly a modification of the LAPACK routine slahqr2.
 c  
 c\Usage:
 c  call slaqrb
@@ -95,7 +95,7 @@ c     Houston, Texas            
 c
 c\Revision history:
 c     xx/xx/92: Version ' 2.4'
-c               Modified from the LAPACK routine slahqr so that only the
+c               Modified from the LAPACK routine slahqr2 so that only the
 c               last component of the Schur vectors are computed.
 c
 c\SCCS Information: @(#) 
diff -rupN SRC-old/snaitr.f SRC/snaitr.f
--- SRC-old/snaitr.f	2014-06-01 16:07:19.000000000 +0530
+++ SRC/snaitr.f	2014-06-01 16:07:38.000000000 +0530
@@ -301,7 +301,7 @@ c        | Set machine-dependent constan
 c        | the splitting and deflation criterion.  |
 c        | If norm(H) <= sqrt(OVFL),               |
 c        | overflow should not occur.              |
-c        | REFERENCE: LAPACK subroutine slahqr     |
+c        | REFERENCE: LAPACK subroutine slahqr2     |
 c        %-----------------------------------------%
 c
          unfl = slamch( 'safe minimum' )
@@ -800,7 +800,7 @@ c     
 c              %--------------------------------------------%
 c              | Check for splitting and deflation.         |
 c              | Use a standard test as in the QR algorithm |
-c              | REFERENCE: LAPACK subroutine slahqr        |
+c              | REFERENCE: LAPACK subroutine slahqr2        |
 c              %--------------------------------------------%
 c     
                tst1 = abs( h( i, i ) ) + abs( h( i+1, i+1 ) )
diff -rupN SRC-old/snapps.f SRC/snapps.f
--- SRC-old/snapps.f	2014-06-01 16:07:19.000000000 +0530
+++ SRC/snapps.f	2014-06-01 16:07:38.000000000 +0530
@@ -132,7 +132,7 @@ c
 c\Remarks
 c  1. In this version, each shift is applied to all the sublocks of
 c     the Hessenberg matrix H and not just to the submatrix that it
-c     comes from. Deflation as in LAPACK routine slahqr (QR algorithm
+c     comes from. Deflation as in LAPACK routine slahqr2 (QR algorithm
 c     for upper Hessenberg matrices ) is used.
 c     The subdiagonals of H are enforced to be non-negative.
 c
@@ -221,7 +221,7 @@ c        %------------------------------
 c        | Set machine-dependent constants for the       |
 c        | stopping criterion. If norm(H) <= sqrt(OVFL), |
 c        | overflow should not occur.                    |
-c        | REFERENCE: LAPACK subroutine slahqr           |
+c        | REFERENCE: LAPACK subroutine slahqr2           |
 c        %-----------------------------------------------%
 c
          unfl = slamch( 'safe minimum' )
@@ -327,7 +327,7 @@ c
 c           %----------------------------------------%
 c           | Check for splitting and deflation. Use |
 c           | a standard test as in the QR algorithm |
-c           | REFERENCE: LAPACK subroutine slahqr    |
+c           | REFERENCE: LAPACK subroutine slahqr2    |
 c           %----------------------------------------%
 c
             tst1 = abs( h( i, i ) ) + abs( h( i+1, i+1 ) )
@@ -562,7 +562,7 @@ c
 c        %--------------------------------------------%
 c        | Final check for splitting and deflation.   |
 c        | Use a standard test as in the QR algorithm |
-c        | REFERENCE: LAPACK subroutine slahqr        |
+c        | REFERENCE: LAPACK subroutine slahqr2        |
 c        %--------------------------------------------%
 c
          tst1 = abs( h( i, i ) ) + abs( h( i+1, i+1 ) )
diff -rupN SRC-old/sneupd.f SRC/sneupd.f
--- SRC-old/sneupd.f	2014-06-01 16:07:19.000000000 +0530
+++ SRC/sneupd.f	2014-06-01 16:07:38.000000000 +0530
@@ -181,7 +181,7 @@ c          Error flag on output.
 c
 c          =  0: Normal exit.
 c
-c          =  1: The Schur form computed by LAPACK routine slahqr
+c          =  1: The Schur form computed by LAPACK routine slahqr2
 c                could not be reordered by LAPACK routine strsen.
 c                Re-enter subroutine sneupd with IPARAM(5)=NCV and 
 c                increase the size of the arrays DR and DI to have 
@@ -197,7 +197,7 @@ c          = -5: WHICH must be one of 'L
 c          = -6: BMAT must be one of 'I' or 'G'.
 c          = -7: Length of private work WORKL array is not sufficient.
 c          = -8: Error return from calculation of a real Schur form.
-c                Informational error from LAPACK routine slahqr.
+c                Informational error from LAPACK routine slahqr2.
 c          = -9: Error return from calculation of eigenvectors.
 c                Informational error from LAPACK routine strevc.
 c          = -10: IPARAM(7) must be 1,2,3,4.
@@ -232,7 +232,7 @@ c     svout   ARPACK utility routine tha
 c     sgeqr2  LAPACK routine that computes the QR factorization of 
 c             a matrix.
 c     slacpy  LAPACK matrix copy routine.
-c     slahqr  LAPACK routine to compute the real Schur form of an
+c     slahqr2  LAPACK routine to compute the real Schur form of an
 c             upper Hessenberg matrix.
 c     slamch  LAPACK routine that determines machine constants.
 c     slapy2  LAPACK routine to compute sqrt(x**2+y**2) carefully.
@@ -364,7 +364,7 @@ c     | External Subroutines |
 c     %----------------------%
 c
       external   scopy , sger  , sgeqr2, slacpy, 
-     &           slahqr, slaset, smout , sorm2r, 
+     &           slahqr2, slaset, smout , sorm2r, 
      &           strevc, strmm , strsen, sscal , 
      &           svout , ivout
 c
@@ -613,7 +613,7 @@ c
          end if
 c
 c        %-----------------------------------------------------------%
-c        | Call LAPACK routine slahqr to compute the real Schur form |
+c        | Call LAPACK routine slahqr2 to compute the real Schur form |
 c        | of the upper Hessenberg matrix returned by SNAUPD.        |
 c        | Make a copy of the upper Hessenberg matrix.               |
 c        | Initialize the Schur vector matrix Q to the identity.     |
@@ -623,7 +623,7 @@ c     
          call slaset('All', ncv, ncv, 
      &                zero , one, workl(invsub),
      &                ldq)
-         call slahqr(.true., .true.       , ncv, 
+         call slahqr2(.true., .true.       , ncv, 
      &                1     , ncv          , workl(iuptri), 
      &                ldh   , workl(iheigr), workl(iheigi),
      &                1     , ncv          , workl(invsub), 
diff -rupN SRC-old/zlahqr2.f SRC/zlahqr2.f
--- SRC-old/zlahqr2.f	1970-01-01 05:30:00.000000000 +0530
+++ SRC/zlahqr2.f	2014-06-01 16:07:38.000000000 +0530
@@ -0,0 +1,385 @@
+      SUBROUTINE ZLAHQR2( WANTT, WANTZ, N, ILO, IHI, H, LDH, W, ILOZ,
+     $                   IHIZ, Z, LDZ, INFO )
+*
+*  -- LAPACK auxiliary routine (version 2.0) --
+*     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
+*     Courant Institute, Argonne National Lab, and Rice University
+*     September 30, 1994
+*
+*     .. Scalar Arguments ..
+      LOGICAL            WANTT, WANTZ
+      INTEGER            IHI, IHIZ, ILO, ILOZ, INFO, LDH, LDZ, N
+*     ..
+*     .. Array Arguments ..
+      COMPLEX*16         H( LDH, * ), W( * ), Z( LDZ, * )
+*     ..
+*
+*  Purpose
+*  =======
+*
+*  ZLAHQR is an auxiliary routine called by CHSEQR to update the
+*  eigenvalues and Schur decomposition already computed by CHSEQR, by
+*  dealing with the Hessenberg submatrix in rows and columns ILO to IHI.
+*
+*  Arguments
+*  =========
+*
+*  WANTT   (input) LOGICAL
+*          = .TRUE. : the full Schur form T is required;
+*          = .FALSE.: only eigenvalues are required.
+*
+*  WANTZ   (input) LOGICAL
+*          = .TRUE. : the matrix of Schur vectors Z is required;
+*          = .FALSE.: Schur vectors are not required.
+*
+*  N       (input) INTEGER
+*          The order of the matrix H.  N >= 0.
+*
+*  ILO     (input) INTEGER
+*  IHI     (input) INTEGER
+*          It is assumed that H is already upper triangular in rows and
+*          columns IHI+1:N, and that H(ILO,ILO-1) = 0 (unless ILO = 1).
+*          ZLAHQR works primarily with the Hessenberg submatrix in rows
+*          and columns ILO to IHI, but applies transformations to all of
+*          H if WANTT is .TRUE..
+*          1 <= ILO <= max(1,IHI); IHI <= N.
+*
+*  H       (input/output) COMPLEX*16 array, dimension (LDH,N)
+*          On entry, the upper Hessenberg matrix H.
+*          On exit, if WANTT is .TRUE., H is upper triangular in rows
+*          and columns ILO:IHI, with any 2-by-2 diagonal blocks in
+*          standard form. If WANTT is .FALSE., the contents of H are
+*          unspecified on exit.
+*
+*  LDH     (input) INTEGER
+*          The leading dimension of the array H. LDH >= max(1,N).
+*
+*  W       (output) COMPLEX*16 array, dimension (N)
+*          The computed eigenvalues ILO to IHI are stored in the
+*          corresponding elements of W. If WANTT is .TRUE., the
+*          eigenvalues are stored in the same order as on the diagonal
+*          of the Schur form returned in H, with W(i) = H(i,i).
+*
+*  ILOZ    (input) INTEGER
+*  IHIZ    (input) INTEGER
+*          Specify the rows of Z to which transformations must be
+*          applied if WANTZ is .TRUE..
+*          1 <= ILOZ <= ILO; IHI <= IHIZ <= N.
+*
+*  Z       (input/output) COMPLEX*16 array, dimension (LDZ,N)
+*          If WANTZ is .TRUE., on entry Z must contain the current
+*          matrix Z of transformations accumulated by CHSEQR, and on
+*          exit Z has been updated; transformations are applied only to
+*          the submatrix Z(ILOZ:IHIZ,ILO:IHI).
+*          If WANTZ is .FALSE., Z is not referenced.
+*
+*  LDZ     (input) INTEGER
+*          The leading dimension of the array Z. LDZ >= max(1,N).
+*
+*  INFO    (output) INTEGER
+*          = 0: successful exit
+*          > 0: if INFO = i, ZLAHQR failed to compute all the
+*               eigenvalues ILO to IHI in a total of 30*(IHI-ILO+1)
+*               iterations; elements i+1:ihi of W contain those
+*               eigenvalues which have been successfully computed.
+*
+*  =====================================================================
+*
+*     .. Parameters ..
+      COMPLEX*16         ZERO, ONE
+      PARAMETER          ( ZERO = ( 0.0D+0, 0.0D+0 ),
+     $                   ONE = ( 1.0D+0, 0.0D+0 ) )
+      DOUBLE PRECISION   RZERO, HALF
+      PARAMETER          ( RZERO = 0.0D+0, HALF = 0.5D+0 )
+*     ..
+*     .. Local Scalars ..
+      INTEGER            I, I1, I2, ITN, ITS, J, K, L, M, NH, NZ
+      DOUBLE PRECISION   H10, H21, RTEMP, S, SMLNUM, T2, TST1, ULP
+      COMPLEX*16         CDUM, H11, H11S, H22, SUM, T, T1, TEMP, U, V2,
+     $                   X, Y
+*     ..
+*     .. Local Arrays ..
+      DOUBLE PRECISION   RWORK( 1 )
+      COMPLEX*16         V( 2 )
+*     ..
+*     .. External Functions ..
+      DOUBLE PRECISION   ZLANHS, DLAMCH
+      COMPLEX*16         ZLADIV
+      EXTERNAL           ZLANHS, DLAMCH, ZLADIV
+*     ..
+*     .. External Subroutines ..
+      EXTERNAL           ZCOPY, ZLARFG, ZSCAL
+*     ..
+*     .. Intrinsic Functions ..
+      INTRINSIC          ABS, DIMAG, DCONJG, MAX, MIN, DBLE, SQRT
+*     ..
+*     .. Statement Functions ..
+      DOUBLE PRECISION   CABS1
+*     ..
+*     .. Statement Function definitions ..
+      CABS1( CDUM ) = ABS( DBLE( CDUM ) ) + ABS( DIMAG( CDUM ) )
+*     ..
+*     .. Executable Statements ..
+*
+      INFO = 0
+*
+*     Quick return if possible
+*
+      IF( N.EQ.0 )
+     $   RETURN
+      IF( ILO.EQ.IHI ) THEN
+         W( ILO ) = H( ILO, ILO )
+         RETURN
+      END IF
+*
+      NH = IHI - ILO + 1
+      NZ = IHIZ - ILOZ + 1
+*
+*     Set machine-dependent constants for the stopping criterion.
+*     If norm(H) <= sqrt(OVFL), overflow should not occur.
+*
+      ULP = DLAMCH( 'Precision' )
+      SMLNUM = DLAMCH( 'Safe minimum' ) / ULP
+*
+*     I1 and I2 are the indices of the first row and last column of H
+*     to which transformations must be applied. If eigenvalues only are
+*     being computed, I1 and I2 are set inside the main loop.
+*
+      IF( WANTT ) THEN
+         I1 = 1
+         I2 = N
+      END IF
+*
+*     ITN is the total number of QR iterations allowed.
+*
+      ITN = 30*NH
+*
+*     The main loop begins here. I is the loop index and decreases from
+*     IHI to ILO in steps of 1. Each iteration of the loop works
+*     with the active submatrix in rows and columns L to I.
+*     Eigenvalues I+1 to IHI have already converged. Either L = ILO, or
+*     H(L,L-1) is negligible so that the matrix splits.
+*
+      I = IHI
+   10 CONTINUE
+      IF( I.LT.ILO )
+     $   GO TO 130
+*
+*     Perform QR iterations on rows and columns ILO to I until a
+*     submatrix of order 1 splits off at the bottom because a
+*     subdiagonal element has become negligible.
+*
+      L = ILO
+      DO 110 ITS = 0, ITN
+*
+*        Look for a single small subdiagonal element.
+*
+         DO 20 K = I, L + 1, -1
+            TST1 = CABS1( H( K-1, K-1 ) ) + CABS1( H( K, K ) )
+            IF( TST1.EQ.RZERO )
+     $         TST1 = ZLANHS( '1', I-L+1, H( L, L ), LDH, RWORK )
+            IF( ABS( DBLE( H( K, K-1 ) ) ).LE.MAX( ULP*TST1, SMLNUM ) )
+     $         GO TO 30
+   20    CONTINUE
+   30    CONTINUE
+         L = K
+         IF( L.GT.ILO ) THEN
+*
+*           H(L,L-1) is negligible
+*
+            H( L, L-1 ) = ZERO
+         END IF
+*
+*        Exit from loop if a submatrix of order 1 has split off.
+*
+         IF( L.GE.I )
+     $      GO TO 120
+*
+*        Now the active submatrix is in rows and columns L to I. If
+*        eigenvalues only are being computed, only the active submatrix
+*        need be transformed.
+*
+         IF( .NOT.WANTT ) THEN
+            I1 = L
+            I2 = I
+         END IF
+*
+         IF( ITS.EQ.10 .OR. ITS.EQ.20 ) THEN
+*
+*           Exceptional shift.
+*
+            T = ABS( DBLE( H( I, I-1 ) ) ) +
+     $          ABS( DBLE( H( I-1, I-2 ) ) )
+         ELSE
+*
+*           Wilkinson's shift.
+*
+            T = H( I, I )
+            U = H( I-1, I )*DBLE( H( I, I-1 ) )
+            IF( U.NE.ZERO ) THEN
+               X = HALF*( H( I-1, I-1 )-T )
+               Y = SQRT( X*X+U )
+               IF( DBLE( X )*DBLE( Y )+DIMAG( X )*DIMAG( Y ).LT.RZERO )
+     $            Y = -Y
+               T = T - ZLADIV( U, ( X+Y ) )
+            END IF
+         END IF
+*
+*        Look for two consecutive small subdiagonal elements.
+*
+         DO 40 M = I - 1, L + 1, -1
+*
+*           Determine the effect of starting the single-shift QR
+*           iteration at row M, and see if this would make H(M,M-1)
+*           negligible.
+*
+            H11 = H( M, M )
+            H22 = H( M+1, M+1 )
+            H11S = H11 - T
+            H21 = H( M+1, M )
+            S = CABS1( H11S ) + ABS( H21 )
+            H11S = H11S / S
+            H21 = H21 / S
+            V( 1 ) = H11S
+            V( 2 ) = H21
+            H10 = H( M, M-1 )
+            TST1 = CABS1( H11S )*( CABS1( H11 )+CABS1( H22 ) )
+            IF( ABS( H10*H21 ).LE.ULP*TST1 )
+     $         GO TO 50
+   40    CONTINUE
+         H11 = H( L, L )
+         H22 = H( L+1, L+1 )
+         H11S = H11 - T
+         H21 = H( L+1, L )
+         S = CABS1( H11S ) + ABS( H21 )
+         H11S = H11S / S
+         H21 = H21 / S
+         V( 1 ) = H11S
+         V( 2 ) = H21
+   50    CONTINUE
+*
+*        Single-shift QR step
+*
+         DO 100 K = M, I - 1
+*
+*           The first iteration of this loop determines a reflection G
+*           from the vector V and applies it from left and right to H,
+*           thus creating a nonzero bulge below the subdiagonal.
+*
+*           Each subsequent iteration determines a reflection G to
+*           restore the Hessenberg form in the (K-1)th column, and thus
+*           chases the bulge one step toward the bottom of the active
+*           submatrix.
+*
+*           V(2) is always real before the call to ZLARFG, and hence
+*           after the call T2 ( = T1*V(2) ) is also real.
+*
+            IF( K.GT.M )
+     $         CALL ZCOPY( 2, H( K, K-1 ), 1, V, 1 )
+            CALL ZLARFG( 2, V( 1 ), V( 2 ), 1, T1 )
+            IF( K.GT.M ) THEN
+               H( K, K-1 ) = V( 1 )
+               H( K+1, K-1 ) = ZERO
+            END IF
+            V2 = V( 2 )
+            T2 = DBLE( T1*V2 )
+*
+*           Apply G from the left to transform the rows of the matrix
+*           in columns K to I2.
+*
+            DO 60 J = K, I2
+               SUM = DCONJG( T1 )*H( K, J ) + T2*H( K+1, J )
+               H( K, J ) = H( K, J ) - SUM
+               H( K+1, J ) = H( K+1, J ) - SUM*V2
+   60       CONTINUE
+*
+*           Apply G from the right to transform the columns of the
+*           matrix in rows I1 to min(K+2,I).
+*
+            DO 70 J = I1, MIN( K+2, I )
+               SUM = T1*H( J, K ) + T2*H( J, K+1 )
+               H( J, K ) = H( J, K ) - SUM
+               H( J, K+1 ) = H( J, K+1 ) - SUM*DCONJG( V2 )
+   70       CONTINUE
+*
+            IF( WANTZ ) THEN
+*
+*              Accumulate transformations in the matrix Z
+*
+               DO 80 J = ILOZ, IHIZ
+                  SUM = T1*Z( J, K ) + T2*Z( J, K+1 )
+                  Z( J, K ) = Z( J, K ) - SUM
+                  Z( J, K+1 ) = Z( J, K+1 ) - SUM*DCONJG( V2 )
+   80          CONTINUE
+            END IF
+*
+            IF( K.EQ.M .AND. M.GT.L ) THEN
+*
+*              If the QR step was started at row M > L because two
+*              consecutive small subdiagonals were found, then extra
+*              scaling must be performed to ensure that H(M,M-1) remains
+*              real.
+*
+               TEMP = ONE - T1
+               TEMP = TEMP / ABS( TEMP )
+               H( M+1, M ) = H( M+1, M )*DCONJG( TEMP )
+               IF( M+2.LE.I )
+     $            H( M+2, M+1 ) = H( M+2, M+1 )*TEMP
+               DO 90 J = M, I
+                  IF( J.NE.M+1 ) THEN
+                     IF( I2.GT.J )
+     $                  CALL ZSCAL( I2-J, TEMP, H( J, J+1 ), LDH )
+                     CALL ZSCAL( J-I1, DCONJG( TEMP ), H( I1, J ), 1 )
+                     IF( WANTZ ) THEN
+                        CALL ZSCAL( NZ, DCONJG( TEMP ),
+     $                              Z( ILOZ, J ), 1 )
+                     END IF
+                  END IF
+   90          CONTINUE
+            END IF
+  100    CONTINUE
+*
+*        Ensure that H(I,I-1) is real.
+*
+         TEMP = H( I, I-1 )
+         IF( DIMAG( TEMP ).NE.RZERO ) THEN
+            RTEMP = ABS( TEMP )
+            H( I, I-1 ) = RTEMP
+            TEMP = TEMP / RTEMP
+            IF( I2.GT.I )
+     $         CALL ZSCAL( I2-I, DCONJG( TEMP ), H( I, I+1 ), LDH )
+            CALL ZSCAL( I-I1, TEMP, H( I1, I ), 1 )
+            IF( WANTZ ) THEN
+               CALL ZSCAL( NZ, TEMP, Z( ILOZ, I ), 1 )
+            END IF
+         END IF
+*
+  110 CONTINUE
+*
+*     Failure to converge in remaining number of iterations
+*
+      INFO = I
+      RETURN
+*
+  120 CONTINUE
+*
+*     H(I,I-1) is negligible: one eigenvalue has converged.
+*
+      W( I ) = H( I, I )
+*
+*     Decrement number of remaining iterations, and return to start of
+*     the main loop with new value of I.
+*
+      ITN = ITN - ITS
+      I = L - 1
+      GO TO 10
+*
+  130 CONTINUE
+      RETURN
+*
+*     End of ZLAHQR
+*
+      END
+
+
+
diff -rupN SRC-old/znaitr.f SRC/znaitr.f
--- SRC-old/znaitr.f	2014-06-01 16:07:19.000000000 +0530
+++ SRC/znaitr.f	2014-06-01 16:07:38.000000000 +0530
@@ -308,7 +308,7 @@ c        | Set machine-dependent constan
 c        | the splitting and deflation criterion.  |
 c        | If norm(H) <= sqrt(OVFL),               |
 c        | overflow should not occur.              |
-c        | REFERENCE: LAPACK subroutine zlahqr     |
+c        | REFERENCE: LAPACK subroutine zlahqr2     |
 c        %-----------------------------------------%
 c
          unfl = dlamch( 'safe minimum' )
@@ -808,7 +808,7 @@ c     
 c              %--------------------------------------------%
 c              | Check for splitting and deflation.         |
 c              | Use a standard test as in the QR algorithm |
-c              | REFERENCE: LAPACK subroutine zlahqr        |
+c              | REFERENCE: LAPACK subroutine zlahqr2        |
 c              %--------------------------------------------%
 c     
                tst1 = dlapy2(dble(h(i,i)),dimag(h(i,i)))
diff -rupN SRC-old/znapps.f SRC/znapps.f
--- SRC-old/znapps.f	2014-06-01 16:07:19.000000000 +0530
+++ SRC/znapps.f	2014-06-01 16:07:38.000000000 +0530
@@ -122,7 +122,7 @@ c
 c\Remarks
 c  1. In this version, each shift is applied to all the sublocks of
 c     the Hessenberg matrix H and not just to the submatrix that it
-c     comes from. Deflation as in LAPACK routine zlahqr (QR algorithm
+c     comes from. Deflation as in LAPACK routine zlahqr2 (QR algorithm
 c     for upper Hessenberg matrices ) is used.
 c     Upon output, the subdiagonals of H are enforced to be non-negative
 c     real numbers.
@@ -224,7 +224,7 @@ c        %------------------------------
 c        | Set machine-dependent constants for the       |
 c        | stopping criterion. If norm(H) <= sqrt(OVFL), |
 c        | overflow should not occur.                    |
-c        | REFERENCE: LAPACK subroutine zlahqr           |
+c        | REFERENCE: LAPACK subroutine zlahqr2           |
 c        %-----------------------------------------------%
 c
          unfl = dlamch( 'safe minimum' )
@@ -282,7 +282,7 @@ c
 c           %----------------------------------------%
 c           | Check for splitting and deflation. Use |
 c           | a standard test as in the QR algorithm |
-c           | REFERENCE: LAPACK subroutine zlahqr    |
+c           | REFERENCE: LAPACK subroutine zlahqr2    |
 c           %----------------------------------------%
 c
             tst1 = zabs1( h( i, i ) ) + zabs1( h( i+1, i+1 ) )
@@ -419,7 +419,7 @@ c
 c        %--------------------------------------------%
 c        | Final check for splitting and deflation.   |
 c        | Use a standard test as in the QR algorithm |
-c        | REFERENCE: LAPACK subroutine zlahqr.       |
+c        | REFERENCE: LAPACK subroutine zlahqr2.       |
 c        | Note: Since the subdiagonals of the        |
 c        | compressed H are nonnegative real numbers, |
 c        | we take advantage of this.                 |
diff -rupN SRC-old/zneigh.f SRC/zneigh.f
--- SRC-old/zneigh.f	2014-06-01 16:07:19.000000000 +0530
+++ SRC/zneigh.f	2014-06-01 16:07:38.000000000 +0530
@@ -51,7 +51,7 @@ c          Private (replicated) array on
 c          the front end. 
 c
 c  IERR    Integer.  (OUTPUT)
-c          Error exit flag from zlahqr or ztrevc.
+c          Error exit flag from zlahqr2 or ztrevc.
 c
 c\EndDoc
 c
@@ -69,7 +69,7 @@ c     zmout   ARPACK utility routine tha
 c     zvout   ARPACK utility routine that prints vectors.
 c     dvout   ARPACK utility routine that prints vectors.
 c     zlacpy  LAPACK matrix copy routine.
-c     zlahqr  LAPACK routine to compute the Schur form of an
+c     zlahqr2  LAPACK routine to compute the Schur form of an
 c             upper Hessenberg matrix.
 c     zlaset  LAPACK matrix initialization routine.
 c     ztrevc  LAPACK routine to compute the eigenvectors of a matrix
@@ -151,7 +151,7 @@ c     %----------------------%
 c     | External Subroutines |
 c     %----------------------%
 c
-      external   zlacpy, zlahqr, ztrevc, zcopy, 
+      external   zlacpy, zlahqr2, ztrevc, zcopy, 
      &           zdscal, zmout, zvout, arscnd
 c
 c     %--------------------%
@@ -183,13 +183,13 @@ c     %---------------------------------
 c     | 1. Compute the eigenvalues, the last components of the   |
 c     |    corresponding Schur vectors and the full Schur form T |
 c     |    of the current upper Hessenberg matrix H.             |
-c     |    zlahqr returns the full Schur form of H               | 
+c     |    zlahqr2 returns the full Schur form of H               | 
 c     |    in WORKL(1:N**2), and the Schur vectors in q.         |
 c     %----------------------------------------------------------%
 c
       call zlacpy ('All', n, n, h, ldh, workl, n)
       call zlaset ('All', n, n, zero, one, q, ldq)
-      call zlahqr (.true., .true., n, 1, n, workl, ldh, ritz,
+      call zlahqr2 (.true., .true., n, 1, n, workl, ldh, ritz,
      &             1, n, q, ldq, ierr)
       if (ierr .ne. 0) go to 9000
 c
diff -rupN SRC-old/zneupd.f SRC/zneupd.f
--- SRC-old/zneupd.f	2014-06-01 16:07:19.000000000 +0530
+++ SRC/zneupd.f	2014-06-01 16:07:38.000000000 +0530
@@ -201,7 +201,7 @@ c     zvout   ARPACK utility routine tha
 c     zgeqr2  LAPACK routine that computes the QR factorization of 
 c             a matrix.
 c     zlacpy  LAPACK matrix copy routine.
-c     zlahqr  LAPACK routine that computes the Schur form of a
+c     zlahqr2  LAPACK routine that computes the Schur form of a
 c             upper Hessenberg matrix.
 c     zlaset  LAPACK matrix initialization routine.
 c     ztrevc  LAPACK routine to compute the eigenvectors of a matrix
@@ -314,7 +314,7 @@ c     %----------------------%
 c
       external   zcopy , zgeru, zgeqr2, zlacpy, zmout,
      &           zunm2r, ztrmm, zvout, ivout,
-     &           zlahqr
+     &           zlahqr2
 c  
 c     %--------------------%
 c     | External Functions |
@@ -548,7 +548,7 @@ c
          end if
 c
 c        %-------------------------------------------------------%
-c        | Call LAPACK routine zlahqr to compute the Schur form |
+c        | Call LAPACK routine zlahqr2 to compute the Schur form |
 c        | of the upper Hessenberg matrix returned by ZNAUPD.   |
 c        | Make a copy of the upper Hessenberg matrix.           |
 c        | Initialize the Schur vector matrix Q to the identity. |
@@ -558,7 +558,7 @@ c
          call zlaset('All', ncv, ncv          , 
      &                zero , one, workl(invsub),
      &                ldq)
-         call zlahqr(.true., .true.       , ncv          , 
+         call zlahqr2(.true., .true.       , ncv          , 
      &                1     , ncv          , workl(iuptri),
      &                ldh   , workl(iheig) , 1            ,
      &                ncv   , workl(invsub), ldq          ,
